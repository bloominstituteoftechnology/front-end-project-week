{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.esm.js","sourcesContent":["/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. üôèüèº\n */\nimport React from 'react';\nimport unquote from 'unquote';\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n    accesskey: 'accessKey',\n    allowfullscreen: 'allowFullScreen',\n    allowtransparency: 'allowTransparency',\n    autocomplete: 'autoComplete',\n    autofocus: 'autoFocus',\n    autoplay: 'autoPlay',\n    cellpadding: 'cellPadding',\n    cellspacing: 'cellSpacing',\n    charset: 'charSet',\n    class: 'className',\n    classid: 'classId',\n    colspan: 'colSpan',\n    contenteditable: 'contentEditable',\n    contextmenu: 'contextMenu',\n    crossorigin: 'crossOrigin',\n    enctype: 'encType',\n    for: 'htmlFor',\n    formaction: 'formAction',\n    formenctype: 'formEncType',\n    formmethod: 'formMethod',\n    formnovalidate: 'formNoValidate',\n    formtarget: 'formTarget',\n    frameborder: 'frameBorder',\n    hreflang: 'hrefLang',\n    inputmode: 'inputMode',\n    keyparams: 'keyParams',\n    keytype: 'keyType',\n    marginheight: 'marginHeight',\n    marginwidth: 'marginWidth',\n    maxlength: 'maxLength',\n    mediagroup: 'mediaGroup',\n    minlength: 'minLength',\n    novalidate: 'noValidate',\n    radiogroup: 'radioGroup',\n    readonly: 'readOnly',\n    rowspan: 'rowSpan',\n    spellcheck: 'spellCheck',\n    srcdoc: 'srcDoc',\n    srclang: 'srcLang',\n    srcset: 'srcSet',\n    tabindex: 'tabIndex',\n    usemap: 'useMap',\n};\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script'];\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ‚Ü≥ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ‚Üì                ‚Ü≥ disabled: true\n *                     ‚Ü≥ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ‚Ü≥ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi;\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\nconst BLOCK_END_R = /\\n{2,}$/;\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/;\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm;\nconst BREAK_LINE_R = /^ {2,}\\n/;\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/;\nconst CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/;\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/;\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/;\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/;\nconst CR_NEWLINE_R = /\\r\\n?/g;\nconst FOOTNOTE_R = /^\\[\\^(.*)\\](:.*)\\n/;\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^(.*)\\]/;\nconst FORMFEED_R = /\\f/g;\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/;\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+)\\n{0,2}/;\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/;\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R = /^ *<([A-Za-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/;\n\nconst HTML_COMMENT_R = /^<!--.*?-->/;\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/;\n\nconst HTML_SELF_CLOSING_ELEMENT_R = /^ *<([A-Za-z][\\w:]*)(?:\\s+((?:<.*?>|[^>])*))?>(?!<\\/\\1>)\\s*/;\nconst INTERPOLATION_R = /^\\{.*\\}$/;\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/;\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/;\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/;\nconst LIST_ITEM_END_R = / *\\n+$/;\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi;\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/;\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/;\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/;\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/;\nconst TAB_R = /\\t/g;\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g;\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/;\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/;\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/;\nconst TABLE_ROW_SPLIT = / *\\| */;\n\n/**\n * (delimiter regex)((?:.*?([`~]).*?\\3.*?)*|(?:.*?[\\[(<].*?[\\])>].*?)*|.+?)\n *\n * detects other inline syntaxes and ignores them; this helps alleviate issues like\n * **Foo `**` baz**\n *\n * Where the ** inside the backticks would be detected as the end of the bolding.\n */\n\n/**\n * Bolding requires the same character to be used twice, so we do a detect for which\n * one is in use, then double-check it's used a second time and then twice at the end.\n *\n * Bits of the mega regex:\n *\n * |[^`~()\\[\\]<>]*?             ignore normal stuff\n * |(?:.*?([`~]).*?\\3.*?)*      ignore stuff in backticks & tildes\n * |(?:.*?\\([^)]*?\\).*?)*       ignore stuff in parens\n * |(?:.*?\\[[^\\]]*?\\].*?)*      ignore stuff in square brackets\n * |(?:.*?<.*?>.*?)*            ignore stuff in angle brackets\n *\n */\nconst TEXT_BOLD_R = /^([*_])\\1((?:[^`~()\\[\\]<>]*?|(?:.*?([`~]).*?\\3.*?)*|(?:.*?\\([^)]*?\\).*?)*|(?:.*?\\[[^\\]]*?\\].*?)*|(?:.*?<.*?>.*?)*|[^\\1]*?)\\1?)\\1{2}/;\nconst TEXT_EMPHASIZED_R = /^([*_])((?:[^`~()\\[\\]<>]*?|(?:.*?([`~]).*?\\3.*?)*|(?:.*?\\([^)]*?\\).*?)*|(?:.*?\\[[^\\]]*?\\].*?)*|(?:.*?<.*?>.*?)*|[^\\1]*?))\\1/;\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:.*?([`~]).*?\\2.*?)*|(?:.*?<.*?>.*?)*|.+?)~~/;\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/;\nconst TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i;\nconst TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|(\\n|\\s)+$)/g;\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi;\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)';\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +';\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX);\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n        '[^\\\\n]*(?:\\\\n' +\n        '(?!\\\\1' +\n        LIST_BULLET +\n        ' )[^\\\\n]*)*(\\\\n|$)',\n    'gm'\n);\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n    '^( *)(' +\n        LIST_BULLET +\n        ') ' +\n        '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n        '(?!\\\\1' +\n        LIST_BULLET +\n        ' )\\\\n*' +\n        // the \\\\s*$ here is so that we can parse the inside of nested\n        // lists, where our content might end before we receive two `\\n`s\n        '|\\\\s*\\\\n*$)'\n);\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*';\nconst LINK_HREF_AND_TITLE =\n    '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*';\n\nconst LINK_R = new RegExp(\n    '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\nconst IMAGE_R = new RegExp(\n    '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\nconst BLOCK_SYNTAXES = [\n    BLOCKQUOTE_R,\n    CODE_BLOCK_R,\n    CODE_BLOCK_FENCED_R,\n    HEADING_R,\n    HEADING_SETEXT_R,\n    HTML_BLOCK_ELEMENT_R,\n    HTML_COMMENT_R,\n    HTML_SELF_CLOSING_ELEMENT_R,\n    LIST_ITEM_R,\n    LIST_R,\n    NP_TABLE_R,\n];\n\nfunction containsBlockSyntax (input) {\n    return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str) {\n    return str\n        .replace(/[√Ä√Å√Ç√É√Ñ√Ö√†√°√¢√£√§√•√¶√Ü]/g, 'a')\n        .replace(/[√ß√á]/g, 'c')\n        .replace(/[√∞√ê]/g, 'd')\n        .replace(/[√à√â√ä√ã√©√®√™√´]/g, 'e')\n        .replace(/[√è√Ø√é√Æ√ç√≠√å√¨]/g, 'i')\n        .replace(/[√ë√±]/g, 'n')\n        .replace(/[√∏√ò≈ì≈í√ï√µ√î√¥√ì√≥√í√≤]/g, 'o')\n        .replace(/[√ú√º√õ√ª√ö√∫√ô√π]/g, 'u')\n        .replace(/[≈∏√ø√ù√Ω]/g, 'y')\n        .replace(/[^a-z0-9- ]/gi, '')\n        .replace(/ /gi, '-')\n        .toLowerCase();\n}\n\nfunction parseTableAlignCapture(alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n        return 'right';\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n        return 'center';\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n        return 'left';\n    }\n\n    return null;\n}\n\nfunction parseTableHeader(capture, parse, state) {\n    const headerText = capture[1]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split(TABLE_ROW_SPLIT);\n\n    return headerText.map(function(text) {\n        return parse(text, state);\n    });\n}\n\nfunction parseTableAlign(capture /*, parse, state*/) {\n    const alignText = capture[2]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split(TABLE_ROW_SPLIT);\n\n    return alignText.map(parseTableAlignCapture);\n}\n\nfunction parseTableCells(capture, parse, state) {\n    const rowsText = capture[3]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split('\\n');\n\n    return rowsText.map(function(rowText) {\n        return rowText\n            .replace(TABLE_TRIM_PIPES, '')\n            .split(TABLE_ROW_SPLIT)\n            .map(function(text) {\n                return parse(text.trim(), state);\n            });\n    });\n}\n\nfunction parseTable(capture, parse, state) {\n    state.inline = true;\n    const header = parseTableHeader(capture, parse, state);\n    const align = parseTableAlign(capture, parse, state);\n    const cells = parseTableCells(capture, parse, state);\n    state.inline = false;\n\n    return {\n        align: align,\n        cells: cells,\n        header: header,\n        type: 'table',\n    };\n}\n\nfunction getTableStyle(node, colIndex) {\n    return node.align[colIndex] == null\n        ? {}\n        : {\n              textAlign: node.align[colIndex],\n          };\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n    const hyphenIndex = key.indexOf('-');\n\n    if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n        key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function(_, letter) {\n            return letter.toUpperCase();\n        });\n    }\n\n    return key;\n}\n\nfunction isInterpolation(value) {\n    return INTERPOLATION_R.test(value);\n}\n\nfunction attributeValueToJSXPropValue(key, value) {\n    if (key === 'style') {\n        return value.split(/;\\s?/).reduce(function(styles, kvPair) {\n            const key = kvPair.slice(0, kvPair.indexOf(':'));\n\n            // snake-case to camelCase\n            // also handles PascalCasing vendor prefixes\n            const camelCasedKey = key.replace(/(-[a-z])/g, function toUpper(\n                substr\n            ) {\n                return substr[1].toUpperCase();\n            });\n\n            // key.length + 1 to skip over the colon\n            styles[camelCasedKey] = kvPair.slice(key.length + 1).trim();\n\n            return styles;\n        }, {});\n    } else if (isInterpolation(value)) {\n        // return as a string and let the consumer decide what to do with it\n        value = value.slice(1, value.length - 1);\n    }\n\n    if (value === 'true') {\n        return true;\n    } else if (value === 'false') {\n        return false;\n    }\n\n    return value;\n}\n\nfunction normalizeWhitespace(source) {\n    return source\n        .replace(CR_NEWLINE_R, '\\n')\n        .replace(FORMFEED_R, '')\n        .replace(TAB_R, '    ');\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(rules) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    let ruleList = Object.keys(rules);\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        ruleList.forEach(function(type) {\n            let order = rules[type].order;\n            if (\n                process.env.NODE_ENV !== 'production' &&\n                (typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined'\n            ) {\n                console.warn(\n                    'markdown-to-jsx: Invalid order for rule `' +\n                        type +\n                        '`: ' +\n                        order\n                );\n            }\n        });\n    }\n\n    ruleList.sort(function(typeA, typeB) {\n        let orderA = rules[typeA].order;\n        let orderB = rules[typeB].order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n\n            // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        }\n\n        return 1;\n    });\n\n    function nestedParse(source, state) {\n        let result = [];\n\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        let prevCapture = '';\n        while (source) {\n            let i = 0;\n            while (i < ruleList.length) {\n                const ruleType = ruleList[i];\n                const rule = rules[ruleType];\n                const capture = rule.match(source, state, prevCapture);\n\n                if (capture) {\n                    const currCaptureString = capture[0];\n                    source = source.substring(currCaptureString.length);\n                    const parsed = rule.parse(capture, nestedParse, state);\n\n                    // We also let rules override the default type of\n                    // their parsed node if they would like to, so that\n                    // there can be a single output function for all links,\n                    // even if there are several rules to parse them.\n                    if (parsed.type == null) {\n                        parsed.type = ruleType;\n                    }\n\n                    result.push(parsed);\n\n                    prevCapture = currCaptureString;\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    return function outerParse(source, state) {\n        return nestedParse(normalizeWhitespace(source), state);\n    };\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex(regex) {\n    return function match(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex(regex) {\n    return function match(source, state) {\n        if (state.inline || state.simple) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex(regex) {\n    return function match(source, state) {\n        if (state.inline || state.simple) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex(regex) {\n    return function match(source /*, state*/) {\n        return regex.exec(source);\n    };\n}\n\nfunction reactFor(outputFunc) {\n    return function nestedReactOutput(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            const oldKey = state.key;\n            const result = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            let lastWasString = false;\n\n            for (let i = 0; i < ast.length; i++) {\n                state.key = i;\n\n                const nodeOut = nestedReactOutput(ast[i], state);\n                const isString = typeof nodeOut === 'string';\n\n                if (isString && lastWasString) {\n                    result[result.length - 1] += nodeOut;\n                } else {\n                    result.push(nodeOut);\n                }\n\n                lastWasString = isString;\n            }\n\n            state.key = oldKey;\n\n            return result;\n        }\n\n        return outputFunc(ast, nestedReactOutput, state);\n    };\n}\n\nfunction sanitizeUrl(url) {\n    try {\n        const prot = decodeURIComponent(url)\n            .replace(/[^A-Z0-9/:]/gi, '')\n            .toLowerCase();\n\n        if (prot.indexOf('javascript:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n\n    return url;\n}\n\nfunction unescapeUrl(rawUrlString) {\n    return rawUrlString.replace(UNESCAPE_URL_R, '$1');\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline(parse, content, state) {\n    const isCurrentlyInline = state.inline || false;\n    const isCurrentlySimple = state.simple || false;\n    state.inline = true;\n    state.simple = true;\n    const result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    state.simple = isCurrentlySimple;\n    return result;\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline(parse, content, state) {\n    const isCurrentlyInline = state.inline || false;\n    const isCurrentlySimple = state.simple || false;\n    state.inline = false;\n    state.simple = true;\n    const result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    state.simple = isCurrentlySimple;\n    return result;\n}\n\nfunction parseBlock(parse, content, state) {\n    state.inline = false;\n    return parse(content + '\\n\\n', state);\n}\n\nfunction parseCaptureInline(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n}\n\nfunction captureNothing() {\n    return {};\n}\nfunction renderNothing() {\n    return null;\n}\n\nfunction ruleOutput(rules) {\n    return function nestedRuleOutput(ast, outputFunc, state) {\n        return rules[ast.type].react(ast, outputFunc, state);\n    };\n}\n\nfunction cx() {\n    return Array.prototype.slice\n        .call(arguments)\n        .filter(Boolean)\n        .join(' ');\n}\n\nfunction get(src, path, fb) {\n    let ptr = src;\n    const frags = path.split('.');\n\n    while (frags.length) {\n        ptr = ptr[frags[0]];\n\n        if (ptr === undefined) break;\n        else frags.shift();\n    }\n\n    return ptr || fb;\n}\n\nfunction getTag(tag, overrides) {\n    const override = get(overrides, tag);\n    return typeof override === 'function'\n        ? override\n        : get(overrides, `${tag}.component`, tag);\n}\n\n/**\n * anything that must scan the tree before everything else\n */\nconst PARSE_PRIORITY_MAX = 1;\n\n/**\n * scans for block-level constructs\n */\nconst PARSE_PRIORITY_HIGH = 2;\n\n/**\n * inline w/ more priority than other inline\n */\nconst PARSE_PRIORITY_MED = 3;\n\n/**\n * inline elements\n */\nconst PARSE_PRIORITY_LOW = 4;\n\n/**\n * bare text and stuff that is considered leftovers\n */\nconst PARSE_PRIORITY_MIN = 5;\n\nexport function compiler(markdown, options) {\n    options = options || {};\n    options.overrides = options.overrides || {};\n    options.slugify = options.slugify || slugify;\n\n    const createElementFn = options.createElement || React.createElement;\n\n    // eslint-disable-next-line no-unused-vars\n    function h(tag, props, ...children) {\n        const overrideProps = get(options.overrides, `${tag}.props`, {});\n\n        return createElementFn(\n            getTag(tag, options.overrides),\n            {\n                ...overrideProps,\n                ...props,\n                className:\n                    cx(props && props.className, overrideProps.className) ||\n                    undefined,\n            },\n            ...children\n        );\n    }\n\n    function compile(input) {\n        let inline = false;\n\n        if (options.forceInline) {\n            inline = true;\n        } else if (!options.forceBlock) {\n            /**\n             * should not contain any block-level markdown like newlines, lists, headings,\n             * thematic breaks, blockquotes, tables, etc\n             */\n            inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false;\n        }\n\n        const arr = emitter(\n            parser(\n                inline\n                    ? input\n                    : `${input.replace(\n                          TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R,\n                          ''\n                      )}\\n\\n`,\n                { inline }\n            )\n        );\n\n        let jsx;\n        if (arr.length > 1) {\n            jsx = inline ? <span>{arr}</span> : <div>{arr}</div>;\n        } else if (arr.length === 1) {\n            jsx = arr[0];\n\n            // TODO: remove this for React 16\n            if (typeof jsx === 'string') {\n                jsx = <span>{jsx}</span>;\n            }\n        } else {\n            // TODO: return null for React 16\n            jsx = <span />;\n        }\n\n        return jsx;\n    }\n\n    function attrStringToMap(str) {\n        const attributes = str.match(ATTR_EXTRACTOR_R);\n\n        return attributes\n            ? attributes.reduce(function(map, raw, index) {\n                  const delimiterIdx = raw.indexOf('=');\n\n                  if (delimiterIdx !== -1) {\n                      const key = normalizeAttributeKey(\n                          raw.slice(0, delimiterIdx)\n                      ).trim();\n                      const value = unquote(raw.slice(delimiterIdx + 1).trim());\n\n                      const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key;\n                      const normalizedValue = (map[\n                          mappedKey\n                      ] = attributeValueToJSXPropValue(key, value));\n\n                      if (\n                          HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n                          HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue)\n                      ) {\n                          map[mappedKey] = React.cloneElement(\n                              compile(normalizedValue.trim()),\n                              { key: index }\n                          );\n                      }\n                  } else {\n                      map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true;\n                  }\n\n                  return map;\n              }, {})\n            : undefined;\n    }\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        if (typeof markdown !== 'string') {\n            throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`);\n        }\n\n        if (\n            Object.prototype.toString.call(options.overrides) !==\n            '[object Object]'\n        ) {\n            throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`);\n        }\n    }\n\n    const footnotes = [];\n    const refs = {};\n\n    /**\n     * each rule's react() output function goes through our custom h() JSX pragma;\n     * this allows the override functionality to be automatically applied\n     */\n    const rules = {\n        blockQuote: {\n            match: blockRegex(BLOCKQUOTE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture, parse, state) {\n                return {\n                    content: parse(\n                        capture[0].replace(\n                            BLOCKQUOTE_TRIM_LEFT_MULTILINE_R,\n                            ''\n                        ),\n                        state\n                    ),\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <blockquote key={state.key}>\n                        {output(node.content, state)}\n                    </blockquote>\n                );\n            },\n        },\n\n        breakLine: {\n            match: anyScopeRegex(BREAK_LINE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react(_, __, state) {\n                return <br key={state.key} />;\n            },\n        },\n\n        breakThematic: {\n            match: blockRegex(BREAK_THEMATIC_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react(_, __, state) {\n                return <hr key={state.key} />;\n            },\n        },\n\n        codeBlock: {\n            match: blockRegex(CODE_BLOCK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                let content = capture[0]\n                    .replace(/^ {4}/gm, '')\n                    .replace(/\\n+$/, '');\n                return {\n                    content: content,\n                    lang: undefined,\n                };\n            },\n\n            react(node, output, state) {\n                return (\n                    <pre key={state.key}>\n                        <code className={node.lang ? `lang-${node.lang}` : ''}>\n                            {node.content}\n                        </code>\n                    </pre>\n                );\n            },\n        },\n\n        codeFenced: {\n            match: blockRegex(CODE_BLOCK_FENCED_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: capture[3],\n                    lang: capture[2] || undefined,\n                    type: 'codeBlock',\n                };\n            },\n        },\n\n        codeInline: {\n            match: simpleInlineRegex(CODE_INLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: capture[2],\n                };\n            },\n            react(node, output, state) {\n                return <code key={state.key}>{node.content}</code>;\n            },\n        },\n\n        /**\n         * footnotes are emitted at the end of compilation in a special <footer> block\n         */\n        footnote: {\n            match: blockRegex(FOOTNOTE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                footnotes.push({\n                    footnote: capture[2],\n                    identifier: capture[1],\n                });\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        footnoteReference: {\n            match: inlineRegex(FOOTNOTE_REFERENCE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture /*, parse*/) {\n                return {\n                    content: capture[1],\n                    target: `#${capture[1]}`,\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <a key={state.key} href={sanitizeUrl(node.target)}>\n                        <sup key={state.key}>{node.content}</sup>\n                    </a>\n                );\n            },\n        },\n\n        gfmTask: {\n            match: inlineRegex(GFM_TASK_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture /*, parse, state*/) {\n                return {\n                    completed: capture[1].toLowerCase() === 'x',\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <input\n                        checked={node.completed}\n                        key={state.key}\n                        readOnly\n                        type=\"checkbox\"\n                    />\n                );\n            },\n        },\n\n        heading: {\n            match: blockRegex(HEADING_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[2], state),\n                    id: options.slugify(capture[2]),\n                    level: capture[1].length,\n                };\n            },\n            react(node, output, state) {\n                const Tag = `h${node.level}`;\n                return (\n                    <Tag id={node.id} key={state.key}>\n                        {output(node.content, state)}\n                    </Tag>\n                );\n            },\n        },\n\n        headingSetext: {\n            match: blockRegex(HEADING_SETEXT_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[1], state),\n                    level: capture[2] === '=' ? 1 : 2,\n                    type: 'heading',\n                };\n            },\n        },\n\n        htmlBlock: {\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture, parse, state) {\n                const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n                const trimmer = new RegExp(`^${whitespace}`, 'gm')\n                const trimmed = capture[3].replace(trimmer, '');\n\n                const parseFunc = containsBlockSyntax(trimmed)\n                    ? parseBlock\n                    : parseInline;\n\n                const noInnerParse =\n                    DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(capture[1]) !== -1;\n\n                return {\n                    attrs: attrStringToMap(capture[2]),\n                    /**\n                     * if another html block is detected within, parse as block,\n                     * otherwise parse as inline to pick up any further markdown\n                     */\n                    content: noInnerParse\n                        ? capture[3]\n                        : parseFunc(parse, trimmed, state),\n\n                    noInnerParse,\n\n                    tag: capture[1],\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <node.tag key={state.key} {...node.attrs}>\n                        {node.noInnerParse\n                            ? node.content\n                            : output(node.content, state)}\n                    </node.tag>\n                );\n            },\n        },\n\n        htmlComment: {\n            match: anyScopeRegex(HTML_COMMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse() {\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        htmlSelfClosing: {\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture /*, parse, state*/) {\n                return {\n                    attrs: attrStringToMap(capture[2] || ''),\n                    tag: capture[1],\n                };\n            },\n            react(node, output, state) {\n                return <node.tag {...node.attrs} key={state.key} />;\n            },\n        },\n\n        image: {\n            match: simpleInlineRegex(IMAGE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture /*, parse, state*/) {\n                return {\n                    alt: capture[1],\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt || undefined}\n                        title={node.title || undefined}\n                        src={sanitizeUrl(node.target)}\n                    />\n                );\n            },\n        },\n\n        link: {\n            match: inlineRegex(LINK_R, false),\n            order: PARSE_PRIORITY_LOW,\n            parse(capture, parse, state) {\n                return {\n                    content: parseSimpleInline(parse, capture[1], state),\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(node.target)}\n                        title={node.title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        // https://daringfireball.net/projects/markdown/syntax#autolink\n        linkAngleBraceStyleDetector: {\n            match: inlineRegex(LINK_AUTOLINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: [\n                        {\n                            content: capture[1],\n                            type: 'text',\n                        },\n                    ],\n                    target: capture[1],\n                    type: 'link',\n                };\n            },\n        },\n\n        linkBareUrlDetector: {\n            match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: [\n                        {\n                            content: capture[1],\n                            type: 'text',\n                        },\n                    ],\n                    target: capture[1],\n                    title: undefined,\n                    type: 'link',\n                };\n            },\n        },\n\n        linkMailtoDetector: {\n            match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse, state*/) {\n                let address = capture[1];\n                let target = capture[1];\n\n                // Check for a `mailto:` already existing in the link:\n                if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                    target = 'mailto:' + target;\n                }\n\n                return {\n                    content: [\n                        {\n                            content: address.replace('mailto:', ''),\n                            type: 'text',\n                        },\n                    ],\n                    target: target,\n                    type: 'link',\n                };\n            },\n        },\n\n        list: {\n            match(source, state, prevCapture) {\n                // We only want to break into a list if we are at the start of a\n                // line. This is to avoid parsing \"hi * there\" with \"* there\"\n                // becoming a part of a list.\n                // You might wonder, \"but that's inline, so of course it wouldn't\n                // start a list?\". You would be correct! Except that some of our\n                // lists can be inline, because they might be inside another list,\n                // in which case we can parse with inline scope, but need to allow\n                // nested lists inside this inline scope.\n                const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture);\n                const isListBlock = state._list || !state.inline;\n\n                if (isStartOfLine && isListBlock) {\n                    source = isStartOfLine[1] + source;\n\n                    return LIST_R.exec(source);\n                } else {\n                    return null;\n                }\n            },\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture, parse, state) {\n                const bullet = capture[2];\n                const ordered = bullet.length > 1;\n                const start = ordered ? +bullet : undefined;\n                const items = capture[0]\n                    // recognize the end of a paragraph block inside a list item:\n                    // two or more newlines at end end of the item\n                    .replace(BLOCK_END_R, '\\n')\n                    .match(LIST_ITEM_R);\n\n                let lastItemWasAParagraph = false;\n                const itemContent = items.map(function(item, i) {\n                    // We need to see how far indented the item is:\n                    const space = LIST_ITEM_PREFIX_R.exec(item)[0].length;\n\n                    // And then we construct a regex to \"unindent\" the subsequent\n                    // lines of the items by that amount:\n                    const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm');\n\n                    // Before processing the item, we need a couple things\n                    const content = item\n                        // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                        // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                    // Handling \"loose\" lists, like:\n                    //\n                    //  * this is wrapped in a paragraph\n                    //\n                    //  * as is this\n                    //\n                    //  * as is this\n                    const isLastItem = i === items.length - 1;\n                    const containsBlocks = content.indexOf('\\n\\n') !== -1;\n\n                    // Any element in a list is a block if it contains multiple\n                    // newlines. The last element in the list can also be a block\n                    // if the previous item in the list was a block (this is\n                    // because non-last items in the list can end with \\n\\n, but\n                    // the last item can't, so we just \"inherit\" this property\n                    // from our previous element).\n                    const thisItemIsAParagraph =\n                        containsBlocks || (isLastItem && lastItemWasAParagraph);\n                    lastItemWasAParagraph = thisItemIsAParagraph;\n\n                    // backup our state for restoration afterwards. We're going to\n                    // want to set state._list to true, and state.inline depending\n                    // on our list's looseness.\n                    const oldStateInline = state.inline;\n                    const oldStateList = state._list;\n                    state._list = true;\n\n                    // Parse inline if we're in a tight list, or block if we're in\n                    // a loose list.\n                    let adjustedContent;\n                    if (thisItemIsAParagraph) {\n                        state.inline = false;\n                        adjustedContent = content.replace(\n                            LIST_ITEM_END_R,\n                            '\\n\\n'\n                        );\n                    } else {\n                        state.inline = true;\n                        adjustedContent = content.replace(LIST_ITEM_END_R, '');\n                    }\n\n                    const result = parse(adjustedContent, state);\n\n                    // Restore our state before returning\n                    state.inline = oldStateInline;\n                    state._list = oldStateList;\n\n                    return result;\n                });\n\n                return {\n                    items: itemContent,\n                    ordered: ordered,\n                    start: start,\n                };\n            },\n            react(node, output, state) {\n                const Tag = node.ordered ? 'ol' : 'ul';\n\n                return (\n                    <Tag key={state.key} start={node.start}>\n                        {node.items.map(function generateListItem(item, i) {\n                            return <li key={i}>{output(item, state)}</li>;\n                        })}\n                    </Tag>\n                );\n            },\n        },\n\n        newlineCoalescer: {\n            match: blockRegex(CONSECUTIVE_NEWLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: captureNothing,\n            react(/*node, output, state*/) {\n                return '\\n';\n            },\n        },\n\n        paragraph: {\n            match: blockRegex(PARAGRAPH_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react(node, output, state) {\n                return <p key={state.key}>{output(node.content, state)}</p>;\n            },\n        },\n\n        ref: {\n            match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture /*, parse*/) {\n                refs[capture[1]] = {\n                    target: capture[2],\n                    title: capture[4],\n                };\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        refImage: {\n            match: simpleInlineRegex(REFERENCE_IMAGE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture) {\n                return {\n                    alt: capture[1] || undefined,\n                    ref: capture[2],\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt}\n                        src={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    />\n                );\n            },\n        },\n\n        refLink: {\n            match: inlineRegex(REFERENCE_LINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse(capture, parse, state) {\n                return {\n                    content: parse(capture[1], state),\n                    ref: capture[2],\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        table: {\n            match: blockRegex(NP_TABLE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: parseTable,\n            react(node, output, state) {\n                return (\n                    <table key={state.key}>\n                        <thead>\n                            <tr>\n                                {node.header.map(function generateHeaderCell(\n                                    content,\n                                    i\n                                ) {\n                                    return (\n                                        <th\n                                            key={i}\n                                            style={getTableStyle(node, i)}\n                                            scope=\"col\"\n                                        >\n                                            {output(content, state)}\n                                        </th>\n                                    );\n                                })}\n                            </tr>\n                        </thead>\n\n                        <tbody>\n                            {node.cells.map(function generateTableRow(row, i) {\n                                return (\n                                    <tr key={i}>\n                                        {row.map(function generateTableCell(\n                                            content,\n                                            c\n                                        ) {\n                                            return (\n                                                <td\n                                                    key={c}\n                                                    style={getTableStyle(\n                                                        node,\n                                                        c\n                                                    )}\n                                                >\n                                                    {output(content, state)}\n                                                </td>\n                                            );\n                                        })}\n                                    </tr>\n                                );\n                            })}\n                        </tbody>\n                    </table>\n                );\n            },\n        },\n\n        text: {\n            // Here we look for anything followed by non-symbols,\n            // double newlines, or double-space-newlines\n            // We break on any symbol characters so that this grammar\n            // is easy to extend without needing to modify this regex\n            match: anyScopeRegex(TEXT_PLAIN_R),\n            order: PARSE_PRIORITY_MIN,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: capture[0],\n                };\n            },\n            react(node /*, output, state*/) {\n                return node.content;\n            },\n        },\n\n        textBolded: {\n            match: simpleInlineRegex(TEXT_BOLD_R),\n            order: PARSE_PRIORITY_MED,\n            parse(capture, parse, state) {\n                return {\n                    // capture[1] -> the syntax control character\n                    // capture[2] -> inner content\n                    content: parse(capture[2], state),\n                };\n            },\n            react(node, output, state) {\n                return (\n                    <strong key={state.key}>\n                        {output(node.content, state)}\n                    </strong>\n                );\n            },\n        },\n\n        textEmphasized: {\n            match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse(capture, parse, state) {\n                return {\n                    // capture[1] -> opening * or _\n                    // capture[2] -> inner content\n                    content: parse(capture[2], state),\n                };\n            },\n            react(node, output, state) {\n                return <em key={state.key}>{output(node.content, state)}</em>;\n            },\n        },\n\n        textEscaped: {\n            // We don't allow escaping numbers, letters, or spaces here so that\n            // backslashes used in plain text still get rendered. But allowing\n            // escaping anything else provides a very flexible escape mechanism,\n            // regardless of how this grammar is extended.\n            match: simpleInlineRegex(TEXT_ESCAPED_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse(capture /*, parse, state*/) {\n                return {\n                    content: capture[1],\n                    type: 'text',\n                };\n            },\n        },\n\n        textStrikethroughed: {\n            match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react(node, output, state) {\n                return <del key={state.key}>{output(node.content, state)}</del>;\n            },\n        },\n    };\n\n    // Object.keys(rules).forEach(key => {\n    //     let { match, parse } = rules[key];\n\n    //     rules[key].match = (...args) => {\n    //         const start = performance.now();\n    //         const result = match(...args);\n    //         const delta = performance.now() - start;\n\n    //         if (delta > 5)\n    //             console.warn(\n    //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n    //                     args[0]\n    //                 }`\n    //             );\n\n    //         return result;\n    //     };\n\n    //     rules[key].parse = (...args) => {\n    //         const start = performance.now();\n    //         const result = parse(...args);\n    //         const delta = performance.now() - start;\n\n    //         if (delta > 5)\n    //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n\n    //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n\n    //         return result;\n    //     };\n    // });\n\n    const parser = parserFor(rules);\n    const emitter = reactFor(ruleOutput(rules));\n\n    const jsx = compile(markdown);\n\n    if (footnotes.length) {\n        jsx.props.children.push(\n            <footer>\n                {footnotes.map(function createFootnote(def) {\n                    return (\n                        <div id={def.identifier} key={def.identifier}>\n                            {def.identifier}\n                            {emitter(parser(def.footnote, { inline: true }))}\n                        </div>\n                    );\n                })}\n            </footer>\n        );\n    }\n\n    return jsx;\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n *\n * @param  {String}   options.children   must be a string\n * @param  {Object}   options.options    markdown-to-jsx options (arg 2 of the compiler)\n *\n * @return {ReactElement} the compiled JSX\n */\n\nexport default function Markdown({ children, options, ...props }) {\n    return React.cloneElement(compiler(children, options), props);\n}\n\nif (process.env.NODE_ENV !== 'production') {\n    const PropTypes = require('prop-types');\n\n    Markdown.propTypes = {\n        children: PropTypes.string.isRequired,\n        options: PropTypes.object,\n    };\n}\n"]}