{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.esm.js","sourcesContent":["/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. 🙏🏼\n */\nimport React from 'react';\nimport unquote from 'unquote';\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n    'accesskey': 'accessKey',\n    'allowfullscreen': 'allowFullScreen',\n    'allowtransparency': 'allowTransparency',\n    'autocomplete': 'autoComplete',\n    'autofocus': 'autoFocus',\n    'autoplay': 'autoPlay',\n    'cellpadding': 'cellPadding',\n    'cellspacing': 'cellSpacing',\n    'charset': 'charSet',\n    'class': 'className',\n    'classid': 'classId',\n    'colspan': 'colSpan',\n    'contenteditable': 'contentEditable',\n    'contextmenu': 'contextMenu',\n    'crossorigin': 'crossOrigin',\n    'enctype': 'encType',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'formenctype': 'formEncType',\n    'formmethod': 'formMethod',\n    'formnovalidate': 'formNoValidate',\n    'formtarget': 'formTarget',\n    'frameborder': 'frameBorder',\n    'hreflang': 'hrefLang',\n    'inputmode': 'inputMode',\n    'keyparams': 'keyParams',\n    'keytype': 'keyType',\n    'marginheight': 'marginHeight',\n    'marginwidth': 'marginWidth',\n    'maxlength': 'maxLength',\n    'mediagroup': 'mediaGroup',\n    'minlength': 'minLength',\n    'novalidate': 'noValidate',\n    'radiogroup': 'radioGroup',\n    'readonly': 'readOnly',\n    'rowspan': 'rowSpan',\n    'spellcheck': 'spellCheck',\n    'srcdoc': 'srcDoc',\n    'srclang': 'srcLang',\n    'srcset': 'srcSet',\n    'tabindex': 'tabIndex',\n    'usemap': 'useMap',\n};\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script'];\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ↳ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ↓                ↳ disabled: true\n *                     ↳ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ↳ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi;\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\nconst BLOCK_END_R = /\\n{2,}$/;\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/;\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm;\nconst BREAK_LINE_R = /^ {2,}\\n/;\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/;\nconst CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n/;\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n/;\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/;\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/;\nconst CR_NEWLINE_R = /\\r\\n?/g;\nconst DETECT_BLOCK_SYNTAX = /(^[-*] |^#+ ?\\w|^ {2,}|^-{2,}|^> )/m;\nconst FOOTNOTE_R = /^\\[\\^(.*)\\](:.*)\\n/;\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^(.*)\\]/;\nconst FORMFEED_R = /\\f/g;\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/;\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+?) *#* *\\n+/;\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/;\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R = /^ *<([^ >/]+) ?([^>]*)\\/{0}>\\s*((?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/;\n\nconst HTML_COMMENT_R = /^<!--.*?-->/;\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria)-[a-z_][a-z\\d_.-]*$/;\n\nconst HTML_SELF_CLOSING_ELEMENT_R = /^ *<([\\w:]+)\\s*((?:<.*?>|[^>])*)>(?!<\\/\\1>)\\s*/;\nconst INTERPOLATION_R = /^\\{.*\\}$/;\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/;\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/;\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/;\nconst LIST_ITEM_END_R = / *\\n+$/;\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi;\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/;\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/;\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/;\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/;\nconst TAB_R = /\\t/g;\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g;\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/;\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/;\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/;\nconst TABLE_ROW_SPLIT = / *\\| */;\nconst TEXT_BOLD_R = /^[*_]{2}([\\s\\S]+?)[*_]{2}(?!\\*|_)/;\nconst TEXT_EMPHASIZED_R = /^[*_]{1}([\\s\\S]+?)[*_]{1}(?!\\*|_)/;\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/;\nconst TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i;\nconst TEXT_STRIKETHROUGHED_R = /^~~(?=\\S)([\\s\\S]*?\\S)~~/;\nconst TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|(\\n|\\s)+$)/g;\n\n/**\n * Indented-style code blocks cannot be used inside arbitrary HTML at this time because\n * it's not clear if the indentation is intentional or just there from how the composer\n * laid things out.\n */\nconst TRIM_HTML = /^\\s*| {4,}|\\s*$/g;\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi;\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)';\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +';\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX);\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' + LIST_BULLET + ' )[^\\\\n]*)*(\\\\n|$)',\n    'gm'\n);\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n    '^( *)(' + LIST_BULLET + ') ' +\n    '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n    '(?!\\\\1' + LIST_BULLET + ' )\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\\\n*$)'\n);\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*';\nconst LINK_HREF_AND_TITLE = '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*';\n\nconst LINK_R = new RegExp(\n    '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\nconst IMAGE_R = new RegExp(\n    '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify (str) {\n    return str\n        .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g,'a')\n        .replace(/[çÇ]/g,'c')\n        .replace(/[ðÐ]/g,'d')\n        .replace(/[ÈÉÊËéèêë]/g,'e')\n        .replace(/[ÏïÎîÍíÌì]/g,'i')\n        .replace(/[Ññ]/g,'n')\n        .replace(/[øØœŒÕõÔôÓóÒò]/g,'o')\n        .replace(/[ÜüÛûÚúÙù]/g,'u')\n        .replace(/[ŸÿÝý]/g,'y')\n        .replace(/[^a-z0-9- ]/gi,'')\n        .replace(/ /gi,'-')\n        .toLowerCase()\n    ;\n}\n\nfunction parseTableAlignCapture (alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n        return 'right';\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n        return 'center';\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n        return 'left';\n    }\n\n    return null;\n}\n\nfunction parseTableHeader (capture, parse, state) {\n    const headerText = capture[1]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split(TABLE_ROW_SPLIT);\n\n    return headerText.map(function (text) { return parse(text, state); });\n}\n\nfunction parseTableAlign (capture/*, parse, state*/) {\n    const alignText = capture[2]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split(TABLE_ROW_SPLIT);\n\n    return alignText.map(parseTableAlignCapture);\n}\n\nfunction parseTableCells (capture, parse, state) {\n    const rowsText = capture[3]\n        .replace(TABLE_TRIM_PIPES, '')\n        .trim()\n        .split('\\n');\n\n    return rowsText.map(function (rowText) {\n        return rowText.replace(TABLE_TRIM_PIPES, '').split(TABLE_ROW_SPLIT).map(function (text) {\n            return parse(text.trim(), state);\n        });\n    });\n}\n\nfunction parseTable (capture, parse, state) {\n    state.inline = true;\n    const header = parseTableHeader(capture, parse, state);\n    const align = parseTableAlign(capture, parse, state);\n    const cells = parseTableCells(capture, parse, state);\n    state.inline = false;\n\n    return {\n        align: align,\n        cells: cells,\n        header: header,\n        type: 'table',\n    };\n}\n\nfunction getTableStyle (node, colIndex) {\n    return node.align[colIndex] == null ? {} : {\n        textAlign: node.align[colIndex],\n    };\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey (key) {\n    const hyphenIndex = key.indexOf('-');\n\n    if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n        key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function (_, letter) { return letter.toUpperCase(); });\n    }\n\n    return key;\n}\n\nfunction isInterpolation (value) {\n    return INTERPOLATION_R.test(value);\n}\n\nfunction attributeValueToJSXPropValue (key, value) {\n    if (key === 'style') {\n        return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n\n            const key = kvPair.slice(0, kvPair.indexOf(':'));\n\n            // snake-case to camelCase\n            // also handles PascalCasing vendor prefixes\n            const camelCasedKey = key.replace(/(-[a-z])/g, function toUpper (substr) {\n                return substr[1].toUpperCase();\n            });\n\n            // key.length + 1 to skip over the colon\n            styles[camelCasedKey] = kvPair.slice(key.length + 1).trim();\n\n            return styles;\n\n        }, {});\n\n    } else if (isInterpolation(value)) {\n        // return as a string and let the consumer decide what to do with it\n        value = value.slice(1, value.length - 1);\n    }\n\n    if (value === 'true') {\n        return true;\n    } else if (value === 'false') {\n        return false;\n    }\n\n    return value;\n}\n\nfunction normalizeWhitespace (source) {\n    return source\n        .replace(CR_NEWLINE_R, '\\n')\n        .replace(FORMFEED_R, '')\n        .replace(TAB_R, '    ')\n    ;\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor (rules) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    let ruleList = Object.keys(rules);\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        ruleList.forEach(function (type) {\n            let order = rules[type].order;\n            if (\n                process.env.NODE_ENV !== 'production'\n                && (typeof order !== 'number' || !isFinite(order))\n                && typeof console !== 'undefined'\n            ) {\n                console.warn(\n                    'markdown-to-jsx: Invalid order for rule `' + type + '`: ' +\n                    order\n                );\n            }\n        });\n    }\n\n    ruleList.sort(function (typeA, typeB) {\n        let orderA = rules[typeA].order;\n        let orderB = rules[typeB].order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        }\n\n        return 1;\n    });\n\n    function nestedParse (source, state) {\n        let result = [];\n\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        let prevCapture = '';\n        while (source) {\n            let i = 0;\n            while (i < ruleList.length) {\n                const ruleType = ruleList[i];\n                const rule = rules[ruleType];\n                const capture = rule.match(source, state, prevCapture);\n\n                if (capture) {\n                    const currCaptureString = capture[0];\n                    source = source.substring(currCaptureString.length);\n                    const parsed = rule.parse(capture, nestedParse, state);\n\n                    // We also let rules override the default type of\n                    // their parsed node if they would like to, so that\n                    // there can be a single output function for all links,\n                    // even if there are several rules to parse them.\n                    if (parsed.type == null) {\n                        parsed.type = ruleType;\n                    }\n\n                    result.push(parsed);\n\n                    prevCapture = currCaptureString;\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    return function outerParse (source, state) {\n        return nestedParse(normalizeWhitespace(source), state);\n    };\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex (regex) {\n    return function match (source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex (regex) {\n    return function match (source, state) {\n        if (state.inline || state.simple) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex (regex) {\n    return function match (source, state) {\n        if (state.inline || state.simple) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex (regex) {\n    return function match (source/*, state*/) {\n        return regex.exec(source);\n    };\n}\n\nfunction reactFor (outputFunc) {\n    return function nestedReactOutput (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            const oldKey = state.key;\n            const result = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            let lastWasString = false;\n\n            for (let i = 0; i < ast.length; i++) {\n                state.key = i;\n\n                const nodeOut = nestedReactOutput(ast[i], state);\n                const isString = typeof nodeOut === 'string';\n\n                if (isString && lastWasString) {\n                    result[result.length - 1] += nodeOut;\n                } else {\n                    result.push(nodeOut);\n                }\n\n                lastWasString = isString;\n            }\n\n            state.key = oldKey;\n\n            return result;\n        }\n\n        return outputFunc(ast, nestedReactOutput, state);\n    };\n}\n\nfunction sanitizeUrl (url) {\n    try {\n        const prot = decodeURIComponent(url)\n            .replace(/[^A-Z0-9/:]/gi, '')\n            .toLowerCase()\n        ;\n\n        if (prot.indexOf('javascript:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n\n    return url;\n}\n\nfunction unescapeUrl (rawUrlString) {\n    return rawUrlString.replace(UNESCAPE_URL_R, '$1');\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline (parse, content, state) {\n    const isCurrentlyInline = state.inline || false;\n    const isCurrentlySimple = state.simple || false;\n    state.inline = true;\n    state.simple = true;\n    const result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    state.simple = isCurrentlySimple;\n    return result;\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline (parse, content, state) {\n    const isCurrentlyInline = state.inline || false;\n    const isCurrentlySimple = state.simple || false;\n    state.inline = false;\n    state.simple = true;\n    const result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    state.simple = isCurrentlySimple;\n    return result;\n}\n\nfunction parseBlock (parse, content, state) {\n    state.inline = false;\n    return parse(content + '\\n\\n', state);\n}\n\nfunction parseCaptureInline (capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n}\n\nfunction captureNothing () { return {}; }\nfunction renderNothing () { return null; }\n\nfunction ruleOutput (rules) {\n    return function nestedRuleOutput (ast, outputFunc, state) {\n        return rules[ast.type].react(ast, outputFunc, state);\n    };\n}\n\nfunction cx () {\n    return Array.prototype.slice.call(arguments).filter(Boolean).join(' ');\n}\n\nfunction get (src, path, fb) {\n    let ptr = src;\n    const frags = path.split('.');\n\n    while (frags.length) {\n        ptr = ptr[frags[0]];\n\n        if (ptr === undefined) break;\n        else frags.shift();\n    }\n\n    return ptr || fb;\n}\n\nfunction getTag (tag, overrides) {\n    const override = get(overrides, tag);\n    return typeof override === 'function'\n        ? override\n        : get(overrides, `${tag}.component`, tag)\n    ;\n}\n\n/**\n * anything that must scan the tree before everything else\n */\nconst PARSE_PRIORITY_MAX = 1;\n\n/**\n * scans for block-level constructs\n */\nconst PARSE_PRIORITY_HIGH = 2;\n\n/**\n * inline w/ more priority than other inline\n */\nconst PARSE_PRIORITY_MED = 3;\n\n/**\n * inline elements\n */\nconst PARSE_PRIORITY_LOW = 4;\n\n/**\n * bare text and stuff that is considered leftovers\n */\nconst PARSE_PRIORITY_MIN = 5;\n\nexport function compiler (markdown, options) {\n    options = options || {};\n    options.overrides = options.overrides || {};\n\n    const createElementFn = options.createElement || React.createElement;\n\n    // eslint-disable-next-line no-unused-vars\n    function h (tag, props, ...children) {\n        const overrideProps = get(options.overrides, `${tag}.props`, {});\n\n        return createElementFn(getTag(tag, options.overrides), {\n            ...overrideProps,\n            ...props,\n            className: cx(props && props.className, overrideProps.className) || undefined,\n        }, ...children);\n    }\n\n    function compile (input) {\n        let inline = false;\n\n        if (options.forceInline) {\n            inline = true;\n        } else if (!options.forceBlock) {\n            /**\n            * should not contain any block-level markdown like newlines, lists, headings,\n            * thematic breaks, blockquotes, tables, etc\n            */\n            inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false;\n        }\n\n        const arr = emitter(\n            parser(\n                inline\n                    ? input\n                    : `${input.replace(TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R, '')}\\n\\n`\n                , { inline }\n            )\n        );\n\n        let jsx;\n        if (arr.length > 1) {\n            jsx = inline ? <span>{arr}</span> : <div>{arr}</div>;\n        } else if (arr.length === 1) {\n            jsx = arr[0];\n\n            // TODO: remove this for React 16\n            if (typeof jsx === 'string') {\n                jsx = <span>{jsx}</span>;\n            }\n        } else {\n            // TODO: return null for React 16\n            jsx = <span />;\n        }\n\n        return jsx;\n    }\n\n    function attrStringToMap (str) {\n        const attributes = str.match(ATTR_EXTRACTOR_R);\n\n        return attributes ? attributes.reduce(function (map, raw, index) {\n            const delimiterIdx = raw.indexOf('=');\n\n            if (delimiterIdx !== -1) {\n                const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim();\n                const value = unquote(raw.slice(delimiterIdx + 1).trim());\n\n                const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key;\n                const normalizedValue = map[mappedKey] = attributeValueToJSXPropValue(key, value);\n\n                if (\n                    HTML_BLOCK_ELEMENT_R.test(normalizedValue)\n                    || HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue)\n                ) {\n                    map[mappedKey] = React.cloneElement(\n                        compile(normalizedValue.trim()), { key: index }\n                    );\n                }\n            } else {\n                map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true;\n            }\n\n            return map;\n        }, {}) : undefined;\n    }\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        if (typeof markdown !== 'string') {\n            throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`);\n        }\n\n        if (Object.prototype.toString.call(options.overrides) !== '[object Object]') {\n            throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`);\n        }\n    }\n\n    const footnotes = [];\n    const refs = {};\n\n    /**\n     * each rule's react() output function goes through our custom h() JSX pragma;\n     * this allows the override functionality to be automatically applied\n     */\n    const rules = {\n        blockQuote: {\n            match: blockRegex(BLOCKQUOTE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''), state),\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <blockquote key={state.key}>\n                        {output(node.content, state)}\n                    </blockquote>\n                );\n            },\n        },\n\n        breakLine: {\n            match: anyScopeRegex(BREAK_LINE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react (_, __, state) {\n                return (\n                    <br key={state.key} />\n                );\n            },\n        },\n\n        breakThematic: {\n            match: blockRegex(BREAK_THEMATIC_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react (_, __, state) {\n                return (\n                    <hr key={state.key} />\n                );\n            },\n        },\n\n        codeBlock: {\n            match: blockRegex(CODE_BLOCK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                let content = capture[0]\n                    .replace(/^ {4}/gm, '')\n                    .replace(/\\n+$/, '');\n                return {\n                    content: content,\n                    lang: undefined,\n                };\n            },\n\n            react (node, output, state) {\n                return (\n                    <pre key={state.key}>\n                        <code className={node.lang ? `lang-${node.lang}` : ''}>\n                            {node.content}\n                        </code>\n                    </pre>\n                );\n            },\n        },\n\n        codeFenced: {\n            match: blockRegex(CODE_BLOCK_FENCED_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[3],\n                    lang: capture[2] || undefined,\n                    type: 'codeBlock',\n                };\n            },\n        },\n\n        codeInline: {\n            match: simpleInlineRegex(CODE_INLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <code key={state.key}>\n                        {node.content}\n                    </code>\n                );\n            },\n        },\n\n        /**\n         * footnotes are emitted at the end of compilation in a special <footer> block\n         */\n        footnote: {\n            match: blockRegex(FOOTNOTE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                footnotes.push({\n                    footnote: capture[2],\n                    identifier: capture[1],\n                });\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        footnoteReference: {\n            match: inlineRegex(FOOTNOTE_REFERENCE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse*/) {\n                return {\n                    content: capture[1],\n                    target: `#${capture[1]}`,\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <a key={state.key} href={sanitizeUrl(node.target)}>\n                        <sup key={state.key}>\n                            {node.content}\n                        </sup>\n                    </a>\n                );\n            },\n        },\n\n        gfmTask: {\n            match: inlineRegex(GFM_TASK_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    completed: capture[1].toLowerCase() === 'x',\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <input\n                        checked={node.completed}\n                        key={state.key}\n                        readOnly\n                        type=\"checkbox\"\n                    />\n                );\n            },\n        },\n\n        heading: {\n            match: blockRegex(HEADING_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[2], state),\n                    id: slugify(capture[2]),\n                    level: capture[1].length,\n                };\n            },\n            react (node, output, state) {\n                const Tag = `h${node.level}`;\n                return (\n                    <Tag id={node.id} key={state.key}>\n                        {output(node.content, state)}\n                    </Tag>\n                );\n            },\n        },\n\n        headingSetext: {\n            match: blockRegex(HEADING_SETEXT_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[1], state),\n                    level: capture[2] === '=' ? 1 : 2,\n                    type: 'heading',\n                };\n            },\n        },\n\n        htmlBlock: {\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                const parseFunc = (\n                    capture[3].match(HTML_BLOCK_ELEMENT_R) || DETECT_BLOCK_SYNTAX.test(capture[3])\n                ) ? parseBlock : parseInline;\n\n                return {\n                    attrs: attrStringToMap(capture[2]),\n                    /**\n                     * if another html block is detected within, parse as block,\n                     * otherwise parse as inline to pick up any further markdown\n                     */\n                    content: DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(capture[1]) !== -1\n                        ? capture[3]\n                        : parseFunc(parse, capture[3].replace(TRIM_HTML, ''), state),\n\n                    tag: capture[1],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <node.tag key={state.key} {...node.attrs}>\n                        {DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(node.tag) !== -1 ? node.content : output(node.content, state)}\n                    </node.tag>\n                );\n            },\n        },\n\n        htmlComment: {\n            match: anyScopeRegex(HTML_COMMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse () { return {}; },\n            react: renderNothing,\n        },\n\n        htmlSelfClosing: {\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    attrs: attrStringToMap(capture[2]),\n                    tag: capture[1],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <node.tag\n                        {...node.attrs}\n                        key={state.key}\n                    />\n                );\n            },\n        },\n\n        image: {\n            match: simpleInlineRegex(IMAGE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    alt: capture[1],\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt || undefined}\n                        title={node.title || undefined}\n                        src={sanitizeUrl(node.target)}\n                    />\n                );\n            },\n        },\n\n        link: {\n            match: inlineRegex(LINK_R, false),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture, parse, state) {\n                return {\n                    content: parseSimpleInline(parse, capture[1], state),\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(node.target)}\n                        title={node.title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        // https://daringfireball.net/projects/markdown/syntax#autolink\n        linkAngleBraceStyleDetector: {\n            match: inlineRegex(LINK_AUTOLINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: [{\n                        content: capture[1],\n                        type: 'text',\n                    }],\n                    target: capture[1],\n                    type: 'link',\n                };\n            },\n        },\n\n        linkBareUrlDetector: {\n            match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: [{\n                        content: capture[1],\n                        type: 'text',\n                    }],\n                    target: capture[1],\n                    title: undefined,\n                    type: 'link',\n                };\n            },\n        },\n\n        linkMailtoDetector: {\n            match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                let address = capture[1];\n                let target = capture[1];\n\n                // Check for a `mailto:` already existing in the link:\n                if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                    target = 'mailto:' + target;\n                }\n\n                return {\n                    content: [{\n                        content: address.replace('mailto:', ''),\n                        type: 'text',\n                    }],\n                    target: target,\n                    type: 'link',\n                };\n            },\n        },\n\n        list: {\n            match (source, state, prevCapture) {\n                // We only want to break into a list if we are at the start of a\n                // line. This is to avoid parsing \"hi * there\" with \"* there\"\n                // becoming a part of a list.\n                // You might wonder, \"but that's inline, so of course it wouldn't\n                // start a list?\". You would be correct! Except that some of our\n                // lists can be inline, because they might be inside another list,\n                // in which case we can parse with inline scope, but need to allow\n                // nested lists inside this inline scope.\n                const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture);\n                const isListBlock = state._list || !state.inline;\n\n                if (isStartOfLine && isListBlock) {\n                    source = isStartOfLine[1] + source;\n\n                    return LIST_R.exec(source);\n                } else {\n                    return null;\n                }\n            },\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                const bullet = capture[2];\n                const ordered = bullet.length > 1;\n                const start = ordered ? +bullet : undefined;\n                const items = capture[0]\n                    // recognize the end of a paragraph block inside a list item:\n                    // two or more newlines at end end of the item\n                    .replace(BLOCK_END_R, '\\n')\n                    .match(LIST_ITEM_R);\n\n                let lastItemWasAParagraph = false;\n                const itemContent = items.map(function (item, i) {\n                    // We need to see how far indented the item is:\n                    const space = LIST_ITEM_PREFIX_R.exec(item)[0].length;\n\n                    // And then we construct a regex to \"unindent\" the subsequent\n                    // lines of the items by that amount:\n                    const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm');\n\n                    // Before processing the item, we need a couple things\n                    const content = item\n                        // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                        // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                    // Handling \"loose\" lists, like:\n                    //\n                    //  * this is wrapped in a paragraph\n                    //\n                    //  * as is this\n                    //\n                    //  * as is this\n                    const isLastItem = (i === items.length - 1);\n                    const containsBlocks = content.indexOf('\\n\\n') !== -1;\n\n                    // Any element in a list is a block if it contains multiple\n                    // newlines. The last element in the list can also be a block\n                    // if the previous item in the list was a block (this is\n                    // because non-last items in the list can end with \\n\\n, but\n                    // the last item can't, so we just \"inherit\" this property\n                    // from our previous element).\n                    const thisItemIsAParagraph = containsBlocks ||\n                            (isLastItem && lastItemWasAParagraph);\n                    lastItemWasAParagraph = thisItemIsAParagraph;\n\n                    // backup our state for restoration afterwards. We're going to\n                    // want to set state._list to true, and state.inline depending\n                    // on our list's looseness.\n                    const oldStateInline = state.inline;\n                    const oldStateList = state._list;\n                    state._list = true;\n\n                    // Parse inline if we're in a tight list, or block if we're in\n                    // a loose list.\n                    let adjustedContent;\n                    if (thisItemIsAParagraph) {\n                        state.inline = false;\n                        adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n');\n                    } else {\n                        state.inline = true;\n                        adjustedContent = content.replace(LIST_ITEM_END_R, '');\n                    }\n\n                    const result = parse(adjustedContent, state);\n\n                    // Restore our state before returning\n                    state.inline = oldStateInline;\n                    state._list = oldStateList;\n\n                    return result;\n                });\n\n                return {\n                    items: itemContent,\n                    ordered: ordered,\n                    start: start,\n                };\n            },\n            react (node, output, state) {\n                const Tag = node.ordered ? 'ol' : 'ul';\n\n                return (\n                    <Tag key={state.key} start={node.start}>\n                        {node.items.map(function generateListItem (item, i) {\n                            return (\n                                <li key={i}>\n                                    {output(item, state)}\n                                </li>\n                            );\n                        })}\n                    </Tag>\n                );\n            },\n        },\n\n        newlineCoalescer: {\n            match: blockRegex(CONSECUTIVE_NEWLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: captureNothing,\n            react (/*node, output, state*/) { return '\\n'; },\n        },\n\n        paragraph: {\n            match: blockRegex(PARAGRAPH_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <p key={state.key}>\n                        {output(node.content, state)}\n                    </p>\n                );\n            },\n        },\n\n        ref: {\n            match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse*/) {\n                refs[capture[1]] = {\n                    target: capture[2],\n                    title: capture[4],\n                };\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        refImage: {\n            match: simpleInlineRegex(REFERENCE_IMAGE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture) {\n                return {\n                    alt: capture[1] || undefined,\n                    ref: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt}\n                        src={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    />\n                );\n            },\n        },\n\n        refLink: {\n            match: inlineRegex(REFERENCE_LINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[1], state),\n                    ref: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        table: {\n            match: blockRegex(NP_TABLE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: parseTable,\n            react (node, output, state) {\n                return (\n                    <table key={state.key}>\n                        <thead>\n                            <tr>\n                                {node.header.map(function generateHeaderCell (content, i) {\n                                    return (\n                                        <th\n                                            key={i}\n                                            style={getTableStyle(node, i)}\n                                            scope=\"col\"\n                                        >\n                                            {output(content, state)}\n                                        </th>\n                                    );\n                                })}\n                            </tr>\n                        </thead>\n\n                        <tbody>\n                            {node.cells.map(function generateTableRow (row, i) {\n                                return (\n                                    <tr key={i}>\n                                        {row.map(function generateTableCell (content, c) {\n                                            return (\n                                                <td key={c} style={getTableStyle(node, c)}>\n                                                    {output(content, state)}\n                                                </td>\n                                            );\n                                        })}\n                                    </tr>\n                                );\n                            })}\n                        </tbody>\n                    </table>\n                );\n            },\n        },\n\n        text: {\n            // Here we look for anything followed by non-symbols,\n            // double newlines, or double-space-newlines\n            // We break on any symbol characters so that this grammar\n            // is easy to extend without needing to modify this regex\n            match: anyScopeRegex(TEXT_PLAIN_R),\n            order: PARSE_PRIORITY_MIN,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[0],\n                };\n            },\n            react (node/*, output, state*/) {\n                return node.content;\n            },\n        },\n\n        textBolded: {\n            match: simpleInlineRegex(TEXT_BOLD_R),\n            order: PARSE_PRIORITY_MED,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <strong key={state.key}>\n                        {output(node.content, state)}\n                    </strong>\n                );\n            },\n        },\n\n        textEmphasized: {\n            match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[2] || capture[1], state),\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <em key={state.key}>\n                        {output(node.content, state)}\n                    </em>\n                );\n            },\n        },\n\n        textEscaped: {\n            // We don't allow escaping numbers, letters, or spaces here so that\n            // backslashes used in plain text still get rendered. But allowing\n            // escaping anything else provides a very flexible escape mechanism,\n            // regardless of how this grammar is extended.\n            match: simpleInlineRegex(TEXT_ESCAPED_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[1],\n                    type: 'text',\n                };\n            },\n        },\n\n        textStrikethroughed: {\n            match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <del key={state.key}>\n                        {output(node.content, state)}\n                    </del>\n                );\n            },\n        },\n    };\n\n    // Object.keys(rules).forEach(key => {\n    //     let parse = rules[key].parse;\n\n    //     rules[key].parse = (...args) => {\n    //         console.log(key, args[0]);\n    //         return parse(...args);\n    //     };\n    // });\n\n    const parser = parserFor(rules);\n    const emitter = reactFor(ruleOutput(rules));\n\n    const jsx = compile(markdown);\n\n    if (footnotes.length) {\n        jsx.props.children.push(\n            <footer>\n                {footnotes.map(function createFootnote (def) {\n                    return (\n                        <div id={def.identifier} key={def.identifier}>\n                            {def.identifier}{emitter(parser(def.footnote, { inline: true }))}\n                        </div>\n                    );\n                })}\n            </footer>\n        );\n    }\n\n    return jsx;\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n *\n * @param  {String}   options.children   must be a string\n * @param  {Object}   options.options    markdown-to-jsx options (arg 2 of the compiler)\n *\n * @return {ReactElement} the compiled JSX\n */\n\nexport default function Markdown ({ children, options, ...props }) {\n    return React.cloneElement(compiler(children, options), props);\n}\n\nif (process.env.NODE_ENV !== 'production') {\n    const PropTypes = require('prop-types');\n\n    Markdown.propTypes = {\n        children: PropTypes.string.isRequired,\n        options: PropTypes.object,\n    };\n}\n"]}