(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('popmotion')) :
    typeof define === 'function' && define.amd ? define(['exports', 'popmotion'], factory) :
    (factory((global.pose = {}),null));
}(this, (function (exports,popmotion) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    var HEY_LISTEN = 'Hey, listen! ';
    var invariant = function () { };
    {
        invariant = function (check, message) {
            if (!check) {
                throw new Error(HEY_LISTEN.toUpperCase() + message);
            }
        };
    }

    var getPoseValues = function (_a) {
        var transition = _a.transition,
            delay = _a.delay,
            delayChildren = _a.delayChildren,
            staggerChildren = _a.staggerChildren,
            staggerDirection = _a.staggerDirection,
            afterChildren = _a.afterChildren,
            beforeChildren = _a.beforeChildren,
            preTransition = _a.preTransition,
            applyAtStart = _a.applyAtStart,
            applyAtEnd = _a.applyAtEnd,
            props = __rest(_a, ["transition", "delay", "delayChildren", "staggerChildren", "staggerDirection", "afterChildren", "beforeChildren", "preTransition", "applyAtStart", "applyAtEnd"]);
        return props;
    };
    var selectPoses = function (_a) {
        var label = _a.label,
            props = _a.props,
            values = _a.values,
            parentValues = _a.parentValues,
            ancestorValues = _a.ancestorValues,
            onChange = _a.onChange,
            passive = _a.passive,
            initialPose = _a.initialPose,
            poses = __rest(_a, ["label", "props", "values", "parentValues", "ancestorValues", "onChange", "passive", "initialPose"]);
        return poses;
    };
    var selectAllValues = function (values, selectValue) {
        var allValues = {};
        values.forEach(function (value, key) {
            return allValues[key] = selectValue(value);
        });
        return allValues;
    };

    var resolveProp = function (target, props) {
        return typeof target === 'function' ? target(props) : target;
    };
    var poseDefault = function (pose, prop, defaultValue, resolveProps) {
        return pose && pose[prop] !== undefined ? resolveProp(pose[prop], resolveProps) : defaultValue;
    };
    var startChildAnimations = function (children, next, pose, props) {
        var animations = [];
        var delay = poseDefault(pose, 'delayChildren', 0, props);
        var stagger = poseDefault(pose, 'staggerChildren', 0, props);
        var staggerDirection = poseDefault(pose, 'staggerDirection', 1, props);
        var maxStaggerDuration = (children.size - 1) * stagger;
        var generateStaggerDuration = staggerDirection === 1 ? function (i) {
            return i * stagger;
        } : function (i) {
            return maxStaggerDuration - i * stagger;
        };
        Array.from(children).forEach(function (child, i) {
            animations.push(child.set(next, __assign({}, props, { delay: delay + generateStaggerDuration(i) })));
        });
        return animations;
    };
    var resolveTransition = function (transition, key, value, props, convertTransitionDefinition, getInstantTransition) {
        var resolvedTransition;
        if (typeof transition === 'function') {
            resolvedTransition = transition(props);
        } else if (transition[key] || transition.default) {
            var keyTransition = transition[key] || transition.default;
            if (typeof keyTransition === 'function') {
                resolvedTransition = keyTransition(props);
            } else {
                resolvedTransition = keyTransition;
            }
        } else {
            resolvedTransition = transition;
        }
        return resolvedTransition === false ? getInstantTransition(value, props) : convertTransitionDefinition(value, resolvedTransition, props);
    };
    var findInsertionIndex = function (poseList, priorityList, priorityIndex) {
        var insertionIndex = 0;
        for (var i = priorityIndex - 1; i >= 0; i--) {
            var nextHighestPriorityIndex = poseList.indexOf(priorityList[i]);
            if (nextHighestPriorityIndex !== -1) {
                insertionIndex = nextHighestPriorityIndex + 1;
                break;
            }
        }
        return insertionIndex;
    };
    var applyValues = function (toApply, values, props, setValue, setValueNative) {
        invariant(typeof toApply === 'object', 'applyAtStart and applyAtEnd must be of type object');
        return Object.keys(toApply).forEach(function (key) {
            var valueToSet = resolveProp(toApply[key], props);
            values.has(key) ? setValue(values.get(key), valueToSet) : setValueNative(key, valueToSet, props);
        });
    };
    var createPoseSetter = function (setterProps) {
        var state = setterProps.state,
            poses = setterProps.poses,
            startAction = setterProps.startAction,
            stopAction = setterProps.stopAction,
            getInstantTransition = setterProps.getInstantTransition,
            addActionDelay = setterProps.addActionDelay,
            getTransitionProps = setterProps.getTransitionProps,
            resolveTarget = setterProps.resolveTarget,
            transformPose = setterProps.transformPose,
            posePriority = setterProps.posePriority,
            convertTransitionDefinition = setterProps.convertTransitionDefinition,
            setValue = setterProps.setValue,
            setValueNative = setterProps.setValueNative;
        return function (next, nextProps, propagate) {
            if (nextProps === void 0) {
                nextProps = {};
            }
            if (propagate === void 0) {
                propagate = true;
            }
            var children = state.children,
                values = state.values,
                props = state.props,
                activeActions = state.activeActions,
                activePoses = state.activePoses;
            var _a = nextProps.delay,
                delay = _a === void 0 ? 0 : _a;
            var hasChildren = children.size;
            var baseTransitionProps = __assign({}, props, nextProps);
            var nextPose = poses[next];
            var getChildAnimations = function () {
                return hasChildren && propagate ? startChildAnimations(children, next, nextPose, baseTransitionProps) : [];
            };
            var getParentAnimations = function () {
                if (!nextPose) return [];
                if (transformPose) nextPose = transformPose(nextPose, next, state);
                var preTransition = nextPose.preTransition,
                    getTransition = nextPose.transition,
                    applyAtStart = nextPose.applyAtStart,
                    applyAtEnd = nextPose.applyAtEnd;
                if (preTransition) preTransition(baseTransitionProps);
                if (applyAtStart) {
                    applyValues(applyAtStart, values, baseTransitionProps, setValue, setValueNative);
                }
                var animations = Object.keys(getPoseValues(nextPose)).map(function (key) {
                    var valuePoses = activePoses.has(key) ? activePoses.get(key) : (activePoses.set(key, []), activePoses.get(key));
                    var existingIndex = valuePoses.indexOf(next);
                    if (existingIndex !== -1) valuePoses.splice(existingIndex, 1);
                    var priority = posePriority ? posePriority.indexOf(next) : 0;
                    var insertionIndex = priority <= 0 ? 0 : findInsertionIndex(valuePoses, posePriority, priority);
                    valuePoses.splice(insertionIndex, 0, next);
                    return insertionIndex === 0 ? new Promise(function (complete) {
                        var value = values.get(key);
                        var transitionProps = __assign({}, baseTransitionProps, { key: key,
                            value: value });
                        var target = resolveTarget(value, resolveProp(nextPose[key], transitionProps));
                        if (activeActions.has(key)) stopAction(activeActions.get(key));
                        var resolveTransitionProps = __assign({ to: target }, transitionProps, getTransitionProps(value, target, transitionProps));
                        var transition = resolveTransition(getTransition, key, value, resolveTransitionProps, convertTransitionDefinition, getInstantTransition);
                        var poseDelay = resolveProp(nextPose.delay, transitionProps);
                        if (delay || poseDelay) {
                            transition = addActionDelay(delay || poseDelay, transition);
                        }
                        activeActions.set(key, startAction(value, transition, complete));
                    }) : Promise.resolve();
                });
                return applyAtEnd ? [Promise.all(animations).then(function () {
                    applyValues(applyAtEnd, values, baseTransitionProps, setValue, setValueNative);
                })] : animations;
            };
            if (nextPose && hasChildren) {
                if (resolveProp(nextPose.beforeChildren, baseTransitionProps)) {
                    return Promise.all(getParentAnimations()).then(function () {
                        return Promise.all(getChildAnimations());
                    });
                } else if (resolveProp(nextPose.afterChildren, baseTransitionProps)) {
                    return Promise.all(getChildAnimations()).then(function () {
                        return Promise.all(getParentAnimations());
                    });
                }
            }
            return Promise.all(getParentAnimations().concat(getChildAnimations()));
        };
    };

    var DEFAULT_INITIAL_POSE = 'init';
    var isScale = function (key) {
        return key.includes('scale');
    };
    var defaultReadValueFromSource = function (key) {
        return isScale(key) ? 1 : 0;
    };
    var readValueFromPose = function (pose, key, props) {
        var valueToResolve = pose.applyAtEnd && pose.applyAtEnd[key] !== undefined ? pose.applyAtEnd[key] : pose[key] !== undefined ? pose[key] : pose.applyAtStart && pose.applyAtStart[key] !== undefined ? pose.applyAtStart[key] : 0;
        return resolveProp(valueToResolve, props);
    };
    var getPosesToSearch = function (pose) {
        var posesToSearch = Array.isArray(pose) ? pose : [pose];
        posesToSearch.push(DEFAULT_INITIAL_POSE);
        return posesToSearch;
    };
    var getInitialValue = function (poses, key, initialPose, props, readValueFromSource, activePoses) {
        if (readValueFromSource === void 0) {
            readValueFromSource = defaultReadValueFromSource;
        }
        var posesToSearch = getPosesToSearch(initialPose);
        var pose = posesToSearch.filter(Boolean).find(function (name) {
            var thisPose = poses[name];
            return thisPose && (thisPose[key] !== undefined || thisPose.applyAtStart && thisPose.applyAtStart[key] !== undefined || thisPose.applyAtEnd && thisPose.applyAtEnd[key] !== undefined);
        });
        activePoses.set(key, [pose || DEFAULT_INITIAL_POSE]);
        return pose ? readValueFromPose(poses[pose], key, props) : readValueFromSource(key, props);
    };
    var createValues = function (values, _a) {
        var userSetValues = _a.userSetValues,
            createValue = _a.createValue,
            convertValue = _a.convertValue,
            readValueFromSource = _a.readValueFromSource,
            initialPose = _a.initialPose,
            poses = _a.poses,
            activePoses = _a.activePoses,
            props = _a.props;
        return function (key) {
            if (values.has(key)) return;
            var value;
            if (userSetValues && userSetValues[key] !== undefined) {
                value = convertValue(userSetValues[key], key, props);
            } else {
                var initValue = getInitialValue(poses, key, initialPose, props, readValueFromSource, activePoses);
                value = createValue(initValue, key, props);
            }
            values.set(key, value);
        };
    };
    var scrapeValuesFromPose = function (values, props) {
        return function (key) {
            var pose = props.poses[key];
            Object.keys(getPoseValues(pose)).forEach(createValues(values, props));
        };
    };
    var getAncestorValue = function (key, fromParent, ancestors) {
        if (fromParent === true) {
            return ancestors[0] && ancestors[0].values.get(key);
        } else {
            var foundAncestor = ancestors.find(function (_a) {
                var label = _a.label;
                return label === fromParent;
            });
            return foundAncestor && foundAncestor.values.get(key);
        }
    };
    var bindPassiveValues = function (values, _a) {
        var passive = _a.passive,
            ancestorValues = _a.ancestorValues,
            createValue = _a.createValue,
            readValue = _a.readValue,
            props = _a.props;
        return function (key) {
            var _a = passive[key],
                valueKey = _a[0],
                passiveProps = _a[1],
                fromParent = _a[2];
            var valueToBind = fromParent && ancestorValues.length ? getAncestorValue(valueKey, fromParent, ancestorValues) : values.has(valueKey) ? values.get(valueKey) : false;
            if (!valueToBind) return;
            var newValue = createValue(readValue(valueToBind), key, props, {
                passiveParentKey: valueKey,
                passiveParent: valueToBind,
                passiveProps: passiveProps
            });
            values.set(key, newValue);
        };
    };
    var setNativeValues = function (_a) {
        var setValueNative = _a.setValueNative,
            initialPose = _a.initialPose,
            props = _a.props,
            poses = _a.poses;
        var valuesHaveSet = new Set();
        var setValues = function (pose, propKey) {
            if (pose[propKey]) {
                for (var key in pose[propKey]) {
                    if (!valuesHaveSet.has(key)) {
                        valuesHaveSet.add(key);
                        setValueNative(key, resolveProp(pose[propKey][key], props), props);
                    }
                }
            }
        };
        getPosesToSearch(initialPose).forEach(function (poseKey) {
            var pose = poses[poseKey];
            if (pose) {
                setValues(pose, 'applyAtEnd');
                setValues(pose, 'applyAtStart');
            }
        });
    };
    var createValueMap = function (props) {
        var poses = props.poses,
            passive = props.passive;
        var values = new Map();
        Object.keys(poses).forEach(scrapeValuesFromPose(values, props));
        setNativeValues(props);
        if (passive) Object.keys(passive).forEach(bindPassiveValues(values, props));
        return values;
    };

    var applyDefaultTransition = function (pose, key, defaultTransitions) {
        return __assign({}, pose, { transition: defaultTransitions.has(key) ? defaultTransitions.get(key) : defaultTransitions.get('default') });
    };
    var generateTransitions = function (poses, defaultTransitions) {
        Object.keys(poses).forEach(function (key) {
            var pose = poses[key];
            invariant(typeof pose === 'object', "Pose '" + key + "' is of invalid type. All poses should be objects.");
            poses[key] = pose.transition !== undefined ? pose : applyDefaultTransition(pose, key, defaultTransitions);
        });
        return poses;
    };

    var sortByReversePriority = function (priorityOrder) {
        return function (a, b) {
            var aP = priorityOrder.indexOf(a);
            var bP = priorityOrder.indexOf(b);
            if (aP === -1 && bP !== -1) return -1;
            if (aP !== -1 && bP === -1) return 1;
            return aP - bP;
        };
    };

    var poseFactory = function (_a) {
        var getDefaultProps = _a.getDefaultProps,
            defaultTransitions = _a.defaultTransitions,
            bindOnChange = _a.bindOnChange,
            startAction = _a.startAction,
            stopAction = _a.stopAction,
            readValue = _a.readValue,
            readValueFromSource = _a.readValueFromSource,
            resolveTarget = _a.resolveTarget,
            setValue = _a.setValue,
            setValueNative = _a.setValueNative,
            createValue = _a.createValue,
            convertValue = _a.convertValue,
            getInstantTransition = _a.getInstantTransition,
            getTransitionProps = _a.getTransitionProps,
            addActionDelay = _a.addActionDelay,
            selectValueToRead = _a.selectValueToRead,
            convertTransitionDefinition = _a.convertTransitionDefinition,
            transformPose = _a.transformPose,
            posePriority = _a.posePriority,
            extendAPI = _a.extendAPI;
        return function (config) {
            var parentValues = config.parentValues,
                _a = config.ancestorValues,
                ancestorValues = _a === void 0 ? [] : _a;
            if (parentValues) ancestorValues.unshift({ values: parentValues });
            var activeActions = new Map();
            var activePoses = new Map();
            var children = new Set();
            var poses = generateTransitions(selectPoses(config), defaultTransitions);
            var props = config.props || {};
            if (getDefaultProps) props = __assign({}, props, getDefaultProps(config));
            var passive = config.passive,
                userSetValues = config.values,
                _b = config.initialPose,
                initialPose = _b === void 0 ? DEFAULT_INITIAL_POSE : _b;
            var values = createValueMap({
                poses: poses,
                passive: passive,
                ancestorValues: ancestorValues,
                readValue: readValue,
                setValueNative: setValueNative,
                createValue: createValue,
                convertValue: convertValue,
                readValueFromSource: readValueFromSource,
                userSetValues: userSetValues,
                initialPose: initialPose,
                activePoses: activePoses,
                props: props
            });
            var state = {
                activeActions: activeActions,
                activePoses: activePoses,
                children: children,
                props: props,
                values: values
            };
            var onChange = config.onChange;
            if (onChange) Object.keys(onChange).forEach(bindOnChange(values, onChange));
            var set = createPoseSetter({
                state: state,
                poses: poses,
                getInstantTransition: getInstantTransition,
                getTransitionProps: getTransitionProps,
                convertTransitionDefinition: convertTransitionDefinition,
                setValue: setValue,
                setValueNative: setValueNative,
                startAction: startAction,
                stopAction: stopAction,
                resolveTarget: resolveTarget,
                addActionDelay: addActionDelay,
                transformPose: transformPose,
                posePriority: posePriority
            });
            var has = function (poseName) {
                return !!poses[poseName];
            };
            var api = {
                set: set,
                unset: function (poseName, poseProps) {
                    var posesToSet = [];
                    activePoses.forEach(function (valuePoses) {
                        var poseIndex = valuePoses.indexOf(poseName);
                        if (poseIndex === -1) return;
                        var currentPose = valuePoses[0];
                        valuePoses.splice(poseIndex, 1);
                        var nextPose = valuePoses[0];
                        if (nextPose === currentPose) return;
                        if (posesToSet.indexOf(nextPose) === -1) {
                            posesToSet.push(nextPose);
                        }
                    });
                    var animationsToResolve = posesToSet.sort(sortByReversePriority(posePriority)).map(function (poseToSet) {
                        return set(poseToSet, poseProps, false);
                    });
                    children.forEach(function (child) {
                        return animationsToResolve.push(child.unset(poseName));
                    });
                    return Promise.all(animationsToResolve);
                },
                get: function (valueName) {
                    return valueName ? selectValueToRead(values.get(valueName)) : selectAllValues(values, selectValueToRead);
                },
                has: has,
                setProps: function (newProps) {
                    return state.props = __assign({}, state.props, newProps);
                },
                _addChild: function (childConfig, factory) {
                    var child = factory(__assign({ initialPose: initialPose }, childConfig, { ancestorValues: [{ label: config.label, values: values }].concat(ancestorValues) }));
                    children.add(child);
                    return child;
                },
                removeChild: function (child) {
                    return children.delete(child);
                },
                clearChildren: function () {
                    children.forEach(function (child) {
                        return child.destroy();
                    });
                    children.clear();
                },
                destroy: function () {
                    activeActions.forEach(stopAction);
                    children.forEach(function (child) {
                        return child.destroy();
                    });
                }
            };
            return extendAPI(api, state, config);
        };
    };

    var linear = function (p) {
        return p;
    };

    var BoundingBoxDimension;
    (function (BoundingBoxDimension) {
        BoundingBoxDimension["width"] = "width";
        BoundingBoxDimension["height"] = "height";
        BoundingBoxDimension["left"] = "left";
        BoundingBoxDimension["right"] = "right";
        BoundingBoxDimension["top"] = "top";
        BoundingBoxDimension["bottom"] = "bottom";
    })(BoundingBoxDimension || (BoundingBoxDimension = {}));

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    var clamp = function (min, max) { return function (v) {
        return Math.max(Math.min(v, max), min);
    }; };
    var isFirstChars = function (term) { return function (v) {
        return typeof v === 'string' && v.indexOf(term) === 0;
    }; };
    var getValueFromFunctionString = function (value) {
        return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
    };
    var splitCommaDelimited = function (value) {
        return typeof value === 'string' ? value.split(/,\s*/) : [value];
    };
    var sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };

    var number = {
        test: function (v) { return typeof v === 'number'; },
        parse: parseFloat,
        transform: function (v) { return v; }
    };
    var alpha = __assign$1({}, number, { transform: clamp(0, 1) });
    var scale = __assign$1({}, number, { default: 1 });

    var createUnitType = function (unit) { return ({
        test: function (v) {
            return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;
        },
        parse: parseFloat,
        transform: function (v) { return "" + v + unit; }
    }); };
    var degrees = createUnitType('deg');
    var percent = createUnitType('%');
    var px = createUnitType('px');
    var vh = createUnitType('vh');
    var vw = createUnitType('vw');

    var clampRgbUnit = clamp(0, 255);
    var isRgba = function (v) { return v.red !== undefined; };
    var isHsla = function (v) { return v.hue !== undefined; };
    var splitColorValues = function (terms) {
        var numTerms = terms.length;
        return function (v) {
            if (typeof v !== 'string')
                return v;
            var values = {};
            var valuesArray = splitCommaDelimited(getValueFromFunctionString(v));
            for (var i = 0; i < numTerms; i++) {
                values[terms[i]] =
                    valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;
            }
            return values;
        };
    };
    var rgbaTemplate = function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
        return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha$$1 + ")";
    };
    var hslaTemplate = function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
        return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha$$1 + ")";
    };
    var rgbUnit = __assign$1({}, number, { transform: function (v) { return Math.round(clampRgbUnit(v)); } });
    var testRgbaString = isFirstChars('rgb');
    var rgba = {
        test: function (v) { return (typeof v === 'string' ? testRgbaString(v) : isRgba(v)); },
        parse: splitColorValues(['red', 'green', 'blue', 'alpha']),
        transform: function (_a) {
            var red = _a.red, green = _a.green, blue = _a.blue, alpha$$1 = _a.alpha;
            return rgbaTemplate({
                red: rgbUnit.transform(red),
                green: rgbUnit.transform(green),
                blue: rgbUnit.transform(blue),
                alpha: sanitize(alpha$$1)
            });
        }
    };
    var testHslaString = isFirstChars('hsl');
    var hsla = {
        test: function (v) { return (typeof v === 'string' ? testHslaString(v) : isHsla(v)); },
        parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),
        transform: function (_a) {
            var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, alpha$$1 = _a.alpha;
            return hslaTemplate({
                hue: Math.round(hue),
                saturation: percent.transform(sanitize(saturation)),
                lightness: percent.transform(sanitize(lightness)),
                alpha: sanitize(alpha$$1)
            });
        }
    };
    var hex = __assign$1({}, rgba, { test: isFirstChars('#'), parse: function (v) {
            var r = '';
            var g = '';
            var b = '';
            if (v.length > 4) {
                r = v.substr(1, 2);
                g = v.substr(3, 2);
                b = v.substr(5, 2);
            }
            else {
                r = v.substr(1, 1);
                g = v.substr(2, 1);
                b = v.substr(3, 1);
                r += r;
                g += g;
                b += b;
            }
            return {
                red: parseInt(r, 16),
                green: parseInt(g, 16),
                blue: parseInt(b, 16),
                alpha: 1
            };
        } });

    var measureWithoutTransform = function (element) {
        var transform = element.style.transform;
        element.style.transform = '';
        var bbox = element.getBoundingClientRect();
        element.style.transform = transform;
        return bbox;
    };
    var resolveProp$1 = function (target, props) {
        return typeof target === 'function' ? target(props) : target;
    };

    var interpolate = popmotion.transform.interpolate;
    var singleAxisPointer = function (axis) { return function (from) {
        var _a;
        return popmotion.pointer((_a = {},
            _a[axis] = typeof from === 'string' ? parseFloat(from) : from,
            _a)).pipe(function (v) { return v[axis]; });
    }; };
    var pointerX = singleAxisPointer('x');
    var pointerY = singleAxisPointer('y');
    var createPointer = function (axisPointerCreator, min, max, measurement) { return function (transitionProps) {
        var from = transitionProps.from, type = transitionProps.type, dimensions = transitionProps.dimensions, dragBounds = transitionProps.dragBounds;
        var axisPointer = axisPointerCreator(dimensions.measurementAsPixels(measurement, from, type));
        var transformQueue = [];
        if (dragBounds) {
            var resolvedDragBounds_1 = resolveProp$1(dragBounds, transitionProps);
            if (resolvedDragBounds_1[min] !== undefined) {
                transformQueue.push(function (v) {
                    return Math.max(v, dimensions.measurementAsPixels(measurement, resolvedDragBounds_1[min], type));
                });
            }
            if (resolvedDragBounds_1[max] !== undefined) {
                transformQueue.push(function (v) {
                    return Math.min(v, dimensions.measurementAsPixels(measurement, resolvedDragBounds_1[max], type));
                });
            }
        }
        if (type === percent) {
            transformQueue.push(interpolate([0, dimensions.get(measurement)], [0, 100]), function (v) { return v + '%'; });
        }
        return transformQueue.length
            ? axisPointer.pipe.apply(axisPointer, transformQueue) : axisPointer;
    }; };
    var just = function (from) {
        return popmotion.action(function (_a) {
            var update = _a.update, complete = _a.complete;
            update(from);
            complete();
        });
    };
    var underDampedSpring = function (_a) {
        var from = _a.from, velocity = _a.velocity, to = _a.to;
        return popmotion.spring({
            from: from,
            to: to,
            velocity: velocity,
            stiffness: 500,
            damping: 25,
            restDelta: 0.5,
            restSpeed: 10
        });
    };
    var overDampedSpring = function (_a) {
        var from = _a.from, velocity = _a.velocity, to = _a.to;
        return popmotion.spring({ from: from, to: to, velocity: velocity, stiffness: 700, damping: to === 0 ? 100 : 35 });
    };
    var linearTween = function (_a) {
        var from = _a.from, to = _a.to;
        return popmotion.tween({ from: from, to: to, ease: linear });
    };
    var intelligentTransition = {
        x: underDampedSpring,
        y: underDampedSpring,
        z: underDampedSpring,
        rotate: underDampedSpring,
        rotateX: underDampedSpring,
        rotateY: underDampedSpring,
        rotateZ: underDampedSpring,
        scaleX: overDampedSpring,
        scaleY: overDampedSpring,
        scale: overDampedSpring,
        opacity: linearTween,
        default: popmotion.tween
    };
    var dragAction = __assign({}, intelligentTransition, { x: createPointer(pointerX, 'left', 'right', BoundingBoxDimension.width), y: createPointer(pointerY, 'top', 'bottom', BoundingBoxDimension.height) });
    var justAxis = function (_a) {
        var from = _a.from;
        return just(from);
    };
    var intelligentDragEnd = __assign({}, intelligentTransition, { x: justAxis, y: justAxis });
    var defaultTransitions = new Map([
        ['default', intelligentTransition],
        ['drag', dragAction],
        ['dragEnd', intelligentDragEnd]
    ]);

    var auto = {
        test: function (v) { return v === 'auto'; },
        parse: function (v) { return v; }
    };
    var valueTypeTests = [number, degrees, percent, px, vw, vh, auto];
    var testValueType = function (v) { return function (type) { return type.test(v); }; };
    var getValueType = function (v) { return valueTypeTests.find(testValueType(v)); };

    var createPassiveValue = function (init, parent, transform) {
        var raw = popmotion.value(transform(init));
        parent.raw.subscribe(function (v) { return raw.update(transform(v)); });
        return { raw: raw };
    };
    var createValue = function (init) {
        var type = getValueType(init);
        var raw = popmotion.value(init);
        return { raw: raw, type: type };
    };
    var addActionDelay = function (delay, transition) {
        if (delay === void 0) { delay = 0; }
        return popmotion.chain(popmotion.delay(delay), transition);
    };
    var animationLookup = {
        tween: popmotion.tween,
        spring: popmotion.spring,
        decay: popmotion.decay,
        keyframes: popmotion.keyframes,
        physics: popmotion.physics
    };
    var linear$1 = popmotion.easing.linear, easeIn$1 = popmotion.easing.easeIn, easeOut$1 = popmotion.easing.easeOut, easeInOut$1 = popmotion.easing.easeInOut, circIn$1 = popmotion.easing.circIn, circOut$1 = popmotion.easing.circOut, circInOut$1 = popmotion.easing.circInOut, backIn$1 = popmotion.easing.backIn, backOut$1 = popmotion.easing.backOut, backInOut$1 = popmotion.easing.backInOut, anticipate$1 = popmotion.easing.anticipate;
    var easingLookup = {
        linear: linear$1,
        easeIn: easeIn$1,
        easeOut: easeOut$1,
        easeInOut: easeInOut$1,
        circIn: circIn$1,
        circOut: circOut$1,
        circInOut: circInOut$1,
        backIn: backIn$1,
        backOut: backOut$1,
        backInOut: backInOut$1,
        anticipate: anticipate$1
    };
    var getAction = function (v, _a, _b) {
        var from = _b.from, to = _b.to, velocity = _b.velocity;
        var _c = _a.type, type = _c === void 0 ? 'tween' : _c, ease = _a.ease, def = __rest(_a, ["type", "ease"]);
        invariant(animationLookup[type] !== undefined, "Invalid transition type '" + type + "'. Valid transition types are: tween, spring, decay, physics and keyframes.");
        if (type === 'tween') {
            var typeOfEase = typeof ease;
            if (typeOfEase !== 'function') {
                if (typeOfEase === 'string') {
                    invariant(easingLookup[ease] !== undefined, "Invalid easing type '" + ease + "'. popmotion.io/pose/api/config");
                    ease = easingLookup[ease];
                }
                else if (Array.isArray(ease)) {
                    invariant(ease.length === 4, "Cubic bezier arrays must contain four numerical values.");
                    var x1 = ease[0], y1 = ease[1], x2 = ease[2], y2 = ease[3];
                    ease = popmotion.easing.cubicBezier(x1, y1, x2, y2);
                }
            }
        }
        var baseProps = type !== 'keyframes'
            ? {
                from: from,
                to: to,
                velocity: velocity,
                ease: ease
            }
            : { ease: ease };
        return animationLookup[type](__assign({}, baseProps, def));
    };
    var isAction = function (action) {
        return typeof action.start !== 'undefined';
    };
    var pose = function (_a) {
        var transformPose = _a.transformPose, addListenerToValue = _a.addListenerToValue, extendAPI = _a.extendAPI, readValueFromSource = _a.readValueFromSource, posePriority = _a.posePriority, setValueNative = _a.setValueNative;
        return poseFactory({
            bindOnChange: function (values, onChange) { return function (key) {
                if (!values.has(key))
                    return;
                var raw = values.get(key).raw;
                raw.subscribe(onChange[key]);
            }; },
            readValue: function (_a) {
                var raw = _a.raw;
                return raw.get();
            },
            setValue: function (_a, to) {
                var raw = _a.raw;
                return raw.update(to);
            },
            createValue: function (init, key, _a, _b) {
                var elementStyler = _a.elementStyler;
                var _c = _b === void 0 ? {} : _b, passiveParent = _c.passiveParent, passiveProps = _c.passiveProps;
                var val = passiveParent
                    ? createPassiveValue(init, passiveParent, passiveProps)
                    : createValue(init);
                if (addListenerToValue) {
                    val.raw.subscribe(addListenerToValue(key, elementStyler));
                }
                return val;
            },
            convertValue: function (raw, key, _a) {
                var elementStyler = _a.elementStyler;
                if (addListenerToValue) {
                    raw.subscribe(addListenerToValue(key, elementStyler));
                }
                return {
                    raw: raw,
                    type: getValueType(raw.get())
                };
            },
            getTransitionProps: function (_a, to) {
                var raw = _a.raw, type = _a.type;
                return ({
                    from: raw.get(),
                    velocity: raw.getVelocity(),
                    to: to,
                    type: type
                });
            },
            resolveTarget: function (_, to) { return to; },
            selectValueToRead: function (_a) {
                var raw = _a.raw;
                return raw;
            },
            startAction: function (_a, action, complete) {
                var raw = _a.raw;
                var reaction = {
                    update: function (v) { return raw.update(v); },
                    complete: complete
                };
                return action.start(reaction);
            },
            stopAction: function (action) { return action.stop(); },
            getInstantTransition: function (_, _a) {
                var to = _a.to;
                return just(to);
            },
            convertTransitionDefinition: function (val, def, props) {
                if (isAction(def))
                    return def;
                var delay = def.delay, min = def.min, max = def.max, round = def.round, remainingDef = __rest(def, ["delay", "min", "max", "round"]);
                var action = getAction(val, remainingDef, props);
                var outputPipe = [];
                if (delay)
                    action = addActionDelay(delay, action);
                if (min !== undefined)
                    outputPipe.push(function (v) { return Math.max(v, min); });
                if (max !== undefined)
                    outputPipe.push(function (v) { return Math.min(v, max); });
                if (round)
                    outputPipe.push(Math.round);
                return outputPipe.length ? action.pipe.apply(action, outputPipe) : action;
            },
            setValueNative: setValueNative,
            addActionDelay: addActionDelay,
            defaultTransitions: defaultTransitions,
            transformPose: transformPose,
            readValueFromSource: readValueFromSource,
            posePriority: posePriority,
            extendAPI: extendAPI
        });
    };

    var createDimensions = (function (element) {
        var hasMeasured = false;
        var current = {
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
        };
        return {
            get: function (measurement) { return (measurement ? current[measurement] : current); },
            measure: function () {
                current = element.getBoundingClientRect();
                hasMeasured = true;
                return current;
            },
            measurementAsPixels: function (measurement, value, type) {
                return type === percent
                    ? (typeof value === 'string' ? parseFloat(value) : value) /
                        100 *
                        current[measurement]
                    : value;
            },
            has: function () { return hasMeasured; }
        };
    });

    var makeUIEventApplicator = function (_a) {
        var startEvents = _a.startEvents, endEvents = _a.endEvents, startPose = _a.startPose, endPose = _a.endPose, startCallback = _a.startCallback, endCallback = _a.endCallback, useDocumentToEnd = _a.useDocumentToEnd, preventDefault = _a.preventDefault;
        return function (element, activeActions, poser, config) {
            var startListener = startPose + 'Start';
            var endListener = startPose + 'End';
            var eventStartListener = popmotion.listen(element, startEvents).start(function (startEvent) {
                if (preventDefault)
                    startEvent.preventDefault();
                poser.set(startPose);
                if (startCallback && config[startCallback])
                    config[startCallback](startEvent);
                var eventEndListener = popmotion.listen(useDocumentToEnd ? document.documentElement : element, endEvents + (useDocumentToEnd ? ' mouseenter' : '')).start(function (endEvent) {
                    if (useDocumentToEnd &&
                        endEvent.type === 'mouseenter' &&
                        endEvent.buttons === 1) {
                        return;
                    }
                    if (preventDefault)
                        endEvent.preventDefault();
                    activeActions.get(endListener).stop();
                    poser.unset(startPose);
                    poser.set(endPose);
                    if (endCallback && config[endCallback])
                        config[endCallback](endEvent);
                });
                activeActions.set(endListener, eventEndListener);
            });
            activeActions.set(startListener, eventStartListener);
        };
    };
    var events = {
        draggable: makeUIEventApplicator({
            startEvents: 'mousedown touchstart',
            endEvents: 'mouseup touchend',
            startPose: 'drag',
            endPose: 'dragEnd',
            startCallback: 'onDragStart',
            endCallback: 'onDragEnd',
            useDocumentToEnd: true,
            preventDefault: true
        }),
        hoverable: makeUIEventApplicator({
            startEvents: 'mouseenter',
            endEvents: 'mouseleave',
            startPose: 'hover',
            endPose: 'hoverEnd'
        }),
        focusable: makeUIEventApplicator({
            startEvents: 'focus',
            endEvents: 'blur',
            startPose: 'focus',
            endPose: 'blur'
        }),
        pressable: makeUIEventApplicator({
            startEvents: 'mousedown touchstart',
            endEvents: 'mouseup touchend',
            startPose: 'press',
            endPose: 'pressEnd',
            startCallback: 'onPressStart',
            endCallback: 'onPressEnd',
            useDocumentToEnd: true
        })
    };
    var eventKeys = Object.keys(events);
    var appendEventListeners = (function (element, activeActions, poser, _a) {
        var props = _a.props;
        return eventKeys.forEach(function (key) {
            if (props[key])
                events[key](element, activeActions, poser, props);
        });
    });

    var ORIGIN_START = 0;
    var ORIGIN_CENTER = '50%';
    var ORIGIN_END = '100%';
    var findCenter = function (_a) {
        var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
        return ({
            x: (left + right) / 2,
            y: (top + bottom) / 2
        });
    };
    var positionalProps = ['width', 'height', 'top', 'left', 'bottom', 'right'];
    var positionalPropsDict = new Set(positionalProps);
    var checkPositionalProp = function (key) { return positionalPropsDict.has(key); };
    var hasPositionalProps = function (pose) {
        return Object.keys(pose).some(checkPositionalProp);
    };
    var isFlipPose = function (flip, key, state) {
        return state.props.element instanceof HTMLElement &&
            (flip === true || key === 'flip');
    };
    var setValue = function (_a, key, to) {
        var values = _a.values, props = _a.props;
        if (values.has(key)) {
            var raw = values.get(key).raw;
            raw.update(to);
            raw.update(to);
        }
        else {
            values.set(key, {
                raw: popmotion.value(to, function (v) { return props.elementStyler.set(key, v); })
            });
        }
    };
    var explicitlyFlipPose = function (state, nextPose) {
        var _a = state.props, dimensions = _a.dimensions, elementStyler = _a.elementStyler;
        dimensions.measure();
        var width = nextPose.width, height = nextPose.height, top = nextPose.top, left = nextPose.left, bottom = nextPose.bottom, right = nextPose.right, position = nextPose.position, remainingPose = __rest(nextPose, ["width", "height", "top", "left", "bottom", "right", "position"]);
        var propsToSet = positionalProps.concat('position').reduce(function (acc, key) {
            if (nextPose[key] !== undefined) {
                acc[key] = resolveProp$1(nextPose[key], state.props);
            }
            return acc;
        }, {});
        elementStyler.set(propsToSet).render();
        return implicitlyFlipPose(state, remainingPose);
    };
    var implicitlyFlipPose = function (state, nextPose) {
        var _a = state.props, dimensions = _a.dimensions, element = _a.element, elementStyler = _a.elementStyler;
        if (!dimensions.has())
            return {};
        var prev = dimensions.get();
        var next = measureWithoutTransform(element);
        var originX = prev.left === next.left
            ? ORIGIN_START
            : prev.right === next.right ? ORIGIN_END : ORIGIN_CENTER;
        var originY = prev.top === next.top
            ? ORIGIN_START
            : prev.bottom === next.bottom ? ORIGIN_END : ORIGIN_CENTER;
        elementStyler.set({ originX: originX, originY: originY });
        var flipPoseProps = {};
        if (prev.width !== next.width) {
            setValue(state, 'scaleX', prev.width / next.width);
            flipPoseProps.scaleX = 1;
        }
        if (prev.height !== next.height) {
            setValue(state, 'scaleY', prev.height / next.height);
            flipPoseProps.scaleY = 1;
        }
        var prevCenter = findCenter(prev);
        var nextCenter = findCenter(next);
        if (originX === ORIGIN_CENTER) {
            setValue(state, 'x', prevCenter.x - nextCenter.x);
            flipPoseProps.x = 0;
        }
        if (originY === ORIGIN_CENTER) {
            setValue(state, 'y', prevCenter.y - nextCenter.y);
            flipPoseProps.y = 0;
        }
        elementStyler.render();
        return __assign({}, nextPose, flipPoseProps);
    };
    var flipPose = function (props, nextPose) {
        return hasPositionalProps(nextPose)
            ? explicitlyFlipPose(props, nextPose)
            : implicitlyFlipPose(props, nextPose);
    };

    var getPosFromMatrix = function (matrix, pos) {
        return parseFloat(matrix.split(', ')[pos]);
    };
    var getTranslateFromMatrix = function (pos2, pos3) { return function (element, bbox, _a) {
        var transform = _a.transform;
        if (transform === 'none')
            return 0;
        var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
        if (matrix3d)
            return getPosFromMatrix(matrix3d[1], pos3);
        return getPosFromMatrix(transform.match(/^matrix\((.+)\)$/)[1], pos2);
    }; };
    var positionalValues = {
        width: function (element, _a) {
            var width = _a.width;
            return width;
        },
        height: function (element, _a) {
            var height = _a.height;
            return height;
        },
        top: function (element, bbox, _a) {
            var top = _a.top;
            return parseFloat(top);
        },
        left: function (element, bbox, _a) {
            var left = _a.left;
            return parseFloat(left);
        },
        bottom: function (element, _a, _b) {
            var height = _a.height;
            var top = _b.top;
            return parseFloat(top) + height;
        },
        right: function (element, _a, _b) {
            var width = _a.width;
            var left = _b.left;
            return parseFloat(left) + width;
        },
        x: getTranslateFromMatrix(4, 13),
        y: getTranslateFromMatrix(5, 14)
    };
    var isPositionalKey = function (v) { return positionalValues[v] !== undefined; };
    var isPositional = function (pose) {
        return Object.keys(pose).some(isPositionalKey);
    };
    var convertPositionalUnits = function (state, pose) {
        var values = state.values, props = state.props;
        var element = props.element, elementStyler = props.elementStyler;
        var positionalPoseKeys = Object.keys(pose).filter(isPositionalKey);
        var changedPositionalKeys = [];
        var elementComputedStyle = getComputedStyle(element);
        positionalPoseKeys.forEach(function (key) {
            var value = values.get(key);
            var fromValueType = getValueType(value.raw.get());
            var to = resolveProp$1(pose[key], props);
            var toValueType = getValueType(to);
            if (fromValueType !== toValueType) {
                changedPositionalKeys.push(key);
                pose.applyAtEnd = pose.applyAtEnd || {};
                pose.applyAtEnd[key] = pose.applyAtEnd[key] || pose[key];
                setValue(state, key, to);
            }
        });
        if (!changedPositionalKeys.length)
            return pose;
        var originBbox = element.getBoundingClientRect();
        var top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;
        var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };
        elementStyler.render();
        var targetBbox = element.getBoundingClientRect();
        var newPose = __assign({}, pose);
        changedPositionalKeys.forEach(function (key) {
            setValue(state, key, positionalValues[key](element, originBbox, originComputedStyle));
            newPose[key] = positionalValues[key](element, targetBbox, elementComputedStyle);
        });
        elementStyler.render();
        return newPose;
    };

    var dragPoses = function (draggable) {
        var drag = {
            preTransition: function (_a) {
                var dimensions = _a.dimensions;
                return dimensions.measure();
            }
        };
        var dragEnd = {};
        if (draggable === true || draggable === 'x')
            drag.x = dragEnd.x = 0;
        if (draggable === true || draggable === 'y')
            drag.y = dragEnd.y = 0;
        return { drag: drag, dragEnd: dragEnd };
    };
    var createPoseConfig = function (element, _a) {
        var onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd, draggable = _a.draggable, hoverable = _a.hoverable, focusable = _a.focusable, pressable = _a.pressable, dragBounds = _a.dragBounds, config = __rest(_a, ["onDragStart", "onDragEnd", "onPressStart", "onPressEnd", "draggable", "hoverable", "focusable", "pressable", "dragBounds"]);
        var poseConfig = __assign({ flip: {} }, config, { props: __assign({}, config.props, { onDragStart: onDragStart,
                onDragEnd: onDragEnd,
                onPressStart: onPressStart,
                onPressEnd: onPressEnd,
                dragBounds: dragBounds,
                draggable: draggable,
                hoverable: hoverable,
                focusable: focusable,
                pressable: pressable,
                element: element, elementStyler: popmotion.styler(element, { preparseOutput: false }), dimensions: createDimensions(element) }) });
        if (draggable) {
            var _b = dragPoses(draggable), drag = _b.drag, dragEnd = _b.dragEnd;
            poseConfig.drag = __assign({}, poseConfig.drag, drag);
            poseConfig.dragEnd = __assign({}, poseConfig.dragEnd, dragEnd);
        }
        return poseConfig;
    };
    var domPose = pose({
        posePriority: ['drag', 'press', 'focus', 'hover'],
        transformPose: function (_a, name, state) {
            var flip = _a.flip, pose$$1 = __rest(_a, ["flip"]);
            if (isFlipPose(flip, name, state)) {
                return flipPose(state, pose$$1);
            }
            else if (isPositional(pose$$1)) {
                return convertPositionalUnits(state, pose$$1);
            }
            return pose$$1;
        },
        addListenerToValue: function (key, elementStyler) { return function (v) { return elementStyler.set(key, v); }; },
        readValueFromSource: function (key, _a) {
            var elementStyler = _a.elementStyler, dragBounds = _a.dragBounds;
            var value = elementStyler.get(key);
            if (dragBounds && (key === 'x' || key === 'y')) {
                var bound = key === 'x'
                    ? dragBounds.left || dragBounds.right
                    : dragBounds.top || dragBounds.bottom;
                if (bound) {
                    var boundType = getValueType(bound);
                    value = boundType.transform(value);
                }
            }
            return isNaN(value) ? value : parseFloat(value);
        },
        setValueNative: function (key, to, _a) {
            var elementStyler = _a.elementStyler;
            return elementStyler.set(key, to);
        },
        extendAPI: function (api, _a, config) {
            var props = _a.props, activeActions = _a.activeActions;
            var measure = props.dimensions.measure;
            var poserApi = __assign({}, api, { addChild: function (element, childConfig) {
                    return api._addChild(createPoseConfig(element, childConfig), domPose);
                }, measure: measure, flip: function (op) {
                    if (op) {
                        measure();
                        op();
                    }
                    return api.set('flip');
                } });
            props.elementStyler.render();
            appendEventListeners(props.element, activeActions, poserApi, config);
            return poserApi;
        }
    });
    var domPose$1 = (function (element, config) {
        return domPose(createPoseConfig(element, config));
    });

    exports.default = domPose$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
